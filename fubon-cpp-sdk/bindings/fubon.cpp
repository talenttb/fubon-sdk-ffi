/* This file was generated by uniffi-bindgen-cpp. */
#include <string>

#include "fubon.hpp"

namespace fubon {
namespace uniffi {
template <class> inline constexpr bool always_false_v = false;

namespace {
void ensure_initialized() {
    auto bindings_contract_version = 24;
    auto scaffolding_contract_version = ffi_fubon_uniffi_contract_version();

    if (bindings_contract_version != scaffolding_contract_version) {
        throw std::runtime_error("UniFFI contract version mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_accounting_bank_remain() != 46056) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_accounting_inventories() != 60564) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_accounting_maintenance() != 31866) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_accounting_query_settlement() != 65476) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_accounting_realized_gains_and_loses() != 42540) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_accounting_realized_gains_and_loses_summary() != 9681) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_accounting_unrealized_gains_and_loses() != 51374) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_fuboncore_dma_login() != 41466) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_fuboncore_exchange_realtime_token() != 57096) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_fuboncore_get_ref() != 17138) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_fuboncore_inner_register_callback() != 44976) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_fuboncore_login() != 56905) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_fuboncore_logout() != 65393) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_fuboncore_recover_event_data() != 53067) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_fuglerealtime_fubon_ws_url() != 56118) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_fuglerealtime_realtime_rest_url() != 17171) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_fuglerealtime_realtime_ws_normal_url() != 50269) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_fuglerealtime_realtime_ws_speed_url() != 26902) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptaccounting_close_position_record() != 23758) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptaccounting_query_hybrid_position() != 54983) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptaccounting_query_margin_equity() != 37408) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptaccounting_query_single_position() != 26332) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_batch_cancel_order() != 61963) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_batch_modify_lot() != 5345) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_batch_modify_price() != 14182) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_batch_order_detail() != 12287) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_batch_order_lists() != 2204) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_batch_place_order() != 11728) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_cancel_condition_orders() != 37277) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_cancel_order() != 47878) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_convert_symbol() != 50241) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_filled_history() != 660) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_get_condition_history() != 9513) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_get_condition_order() != 48545) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_get_condition_order_by_id() != 59239) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_get_order_results() != 46254) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_get_order_results_detail() != 11418) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_get_time_slice_order() != 53789) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_get_trail_history() != 65467) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_get_trail_order() != 43342) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_make_modify_lot_obj() != 39517) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_make_modify_price_obj() != 428) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_modify_lot() != 46427) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_modify_price() != 13556) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_multi_condition() != 18192) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_order_history() != 33201) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_place_order() != 61902) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_query_estimate_margin() != 31598) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_single_condition() != 47296) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_time_slice_order() != 56646) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_futoptfunctions_trail_profit() != 9773) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_batch_cancel_order() != 51262) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_batch_modify_price() != 54225) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_batch_modify_quantity() != 46070) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_batch_order_detail() != 61553) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_batch_order_lists() != 49373) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_batch_place_order() != 5920) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_cancel_condition_orders() != 2890) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_cancel_order() != 59858) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_daytrade_and_stock_info() != 51038) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_filled_history() != 58654) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_get_condition_daytrade_by_id() != 61351) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_get_condition_history() != 5214) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_get_condition_order() != 40956) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_get_condition_order_by_id() != 58574) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_get_order_results() != 62678) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_get_order_results_detail() != 40626) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_get_time_slice_order() != 62920) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_get_trail_history() != 25175) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_get_trail_order() != 292) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_make_modify_price_obj() != 41157) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_make_modify_quantity_obj() != 5937) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_margin_quota() != 52579) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_modify_price() != 23789) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_modify_quantity() != 39363) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_multi_condition() != 42671) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_multi_condition_day_trade() != 52146) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_multi_condition_stop() != 26621) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_order_history() != 39672) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_place_order() != 34432) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_query_symbol_quote() != 25693) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_query_symbol_snapshot() != 58501) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_single_condition() != 41018) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_single_condition_day_trade() != 52089) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_single_condition_stop() != 45983) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_time_slice_order() != 27737) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_stockfunctions_trail_profit() != 21090) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_constructor_fuboncore_new() != 6255) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_constructor_fuglerealtime_new() != 3555) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_callback_on_order() != 42631) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_callback_on_order_changed() != 25976) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_callback_on_filled() != 27681) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_callback_on_futopt_order() != 37007) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_callback_on_futopt_order_changed() != 26627) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_callback_on_futopt_filled() != 23580) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_fubon_checksum_method_callback_on_event() != 55482) {
        throw std::runtime_error("UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
}

// Note: we need this indirection here and can't inline this code in the rust_call function
// as it's a templated function
void initialize() {
    static std::once_flag init_flag;
    std::call_once(init_flag, ensure_initialized);
}
}

template <typename F>
void check_rust_call(const RustCallStatus &status, F error_cb) {
    switch (status.code) {
    case 0:
        return;

    case 1:
        if constexpr (!std::is_null_pointer_v<F>) {
            error_cb(status.error_buf)->throw_underlying();
        }
        break;

    case 2:
        if (status.error_buf.len > 0) {
            throw std::runtime_error(FfiConverterString::lift(status.error_buf));
        }

        throw std::runtime_error("A Rust panic has occurred");
    }

    throw std::runtime_error("Unexpected Rust call status");
}

template <typename F, typename EF, typename... Args, typename R = std::invoke_result_t<F, Args..., RustCallStatus *>>
R rust_call(F f, EF error_cb, Args... args) {
    initialize();

    RustCallStatus status = { 0 };

    if constexpr (std::is_void_v<R>) {
        f(args..., &status);
        check_rust_call(status, error_cb);
    } else {
        auto ret = f(args..., &status);
        check_rust_call(status, error_cb);

        return ret;
    }
}

RustBuffer rustbuffer_alloc(int32_t len) {
    RustCallStatus status = { 0 };
    auto buffer = ffi_fubon_rustbuffer_alloc(len, &status);

    check_rust_call(status, nullptr);

    return buffer;
}

RustBuffer rustbuffer_from_bytes(const ForeignBytes &bytes) {
    RustCallStatus status = { 0 };
    auto buffer = ffi_fubon_rustbuffer_from_bytes(bytes, &status);

    check_rust_call(status, nullptr);

    return buffer;
}

void rustbuffer_free(RustBuffer buf) {
    RustCallStatus status = { 0 };

    ffi_fubon_rustbuffer_free(std::move(buf), &status);
    check_rust_call(status, nullptr);
}


int32_t FfiConverterInt32::lift(int32_t val) {
    return val;
}

int32_t FfiConverterInt32::lower(int32_t val) {
    return val;
}

int32_t FfiConverterInt32::read(RustStream &stream) {
    int32_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterInt32::write(RustStream &stream, int32_t val) {
    stream << val;
}

int32_t FfiConverterInt32::allocation_size(int32_t) {
    return static_cast<int32_t>(sizeof(int32_t));
}
uint64_t FfiConverterUInt64::lift(uint64_t val) {
    return val;
}

uint64_t FfiConverterUInt64::lower(uint64_t val) {
    return val;
}

uint64_t FfiConverterUInt64::read(RustStream &stream) {
    uint64_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterUInt64::write(RustStream &stream, uint64_t val) {
    stream << val;
}

int32_t FfiConverterUInt64::allocation_size(uint64_t) {
    return static_cast<int32_t>(sizeof(uint64_t));
}
int64_t FfiConverterInt64::lift(int64_t val) {
    return val;
}

int64_t FfiConverterInt64::lower(int64_t val) {
    return val;
}

int64_t FfiConverterInt64::read(RustStream &stream) {
    int64_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterInt64::write(RustStream &stream, int64_t val) {
    stream << val;
}

int32_t FfiConverterInt64::allocation_size(int64_t) {
    return static_cast<int32_t>(sizeof(int64_t));
}
double FfiConverterDouble::lift(double val) {
    return val;
}

double FfiConverterDouble::lower(double val) {
    return val;
}

double FfiConverterDouble::read(RustStream &stream) {
    double ret;
    stream >> ret;

    return ret;
}

void FfiConverterDouble::write(RustStream &stream, double val) {
    stream << val;
}

int32_t FfiConverterDouble::allocation_size(double) {
    return static_cast<int32_t>(sizeof(double));
}

bool FfiConverterBool::lift(uint8_t val) {
    return !!val;
}

uint8_t FfiConverterBool::lower(bool val) {
    return val;
}

bool FfiConverterBool::read(RustStream &stream) {
    uint8_t val;
    stream >> val;

    return val;
}

void FfiConverterBool::write(RustStream &stream, bool val) {
    stream << val;
}

int32_t FfiConverterBool::allocation_size(bool) {
    return 1;
}
std::string FfiConverterString::lift(RustBuffer buf) {
    auto string = std::string(reinterpret_cast<char *>(buf.data), buf.len);

    rustbuffer_free(buf);

    return string;
}

RustBuffer FfiConverterString::lower(const std::string &val) {
    auto len = static_cast<int32_t>(val.length());
    auto bytes = ForeignBytes { len, reinterpret_cast<uint8_t *>(const_cast<char *>(val.data())) };

    return rustbuffer_from_bytes(bytes);
}

std::string FfiConverterString::read(RustStream &stream) {
    int32_t len;
    std::string string;

    stream >> len;

    string.resize(len);
    stream.read(string.data(), len);

    return string;
}

void FfiConverterString::write(RustStream &stream, const std::string &val) {
    stream << static_cast<int32_t>(val.length());
    stream.write(val.data(), val.length());
}

int32_t FfiConverterString::allocation_size(const std::string &val) {
    return static_cast<int32_t>(sizeof(int32_t) + val.length());
}
} // namespace uniffi









Accounting::Accounting(void *ptr): instance(ptr) {}


BankRemainResponse Accounting::bank_remain(const Account &account) {
    return uniffi::FfiConverterTypeBankRemainResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_accounting_bank_remain,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account)));
}
InventoryResponse Accounting::inventories(const Account &account) {
    return uniffi::FfiConverterTypeInventoryResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_accounting_inventories,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account)));
}
MaintenanceResponse Accounting::maintenance(const Account &account) {
    return uniffi::FfiConverterTypeMaintenanceResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_accounting_maintenance,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account)));
}
SettlementResponse Accounting::query_settlement(const Account &account, const std::string &range) {
    return uniffi::FfiConverterTypeSettlementResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_accounting_query_settlement,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(range)));
}
RealizedResponse Accounting::realized_gains_and_loses(const Account &account) {
    return uniffi::FfiConverterTypeRealizedResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_accounting_realized_gains_and_loses,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account)));
}
RealizedSummaryResponse Accounting::realized_gains_and_loses_summary(const Account &account) {
    return uniffi::FfiConverterTypeRealizedSummaryResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_accounting_realized_gains_and_loses_summary,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account)));
}
UnRealizedResponse Accounting::unrealized_gains_and_loses(const Account &account) {
    return uniffi::FfiConverterTypeUnRealizedResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_accounting_unrealized_gains_and_loses,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account)));
}

Accounting::~Accounting() {
    uniffi::rust_call(
        uniffi_fubon_fn_free_accounting,
        nullptr,
        this->instance
    );
}


FubonCore::FubonCore(void *ptr): instance(ptr) {}


std::shared_ptr<FubonCore> FubonCore::init(std::optional<uint64_t> pong_inteval, std::optional<int64_t> missed_count, std::optional<std::string> url) {
    return std::shared_ptr<FubonCore>(
        new FubonCore(uniffi::rust_call(
        uniffi_fubon_fn_constructor_fuboncore_new,
        nullptr, uniffi::FfiConverterOptionalUInt64::lower(pong_inteval), uniffi::FfiConverterOptionalInt64::lower(missed_count), uniffi::FfiConverterOptionalString::lower(url)))
    );
}

LoginResponse FubonCore::dma_login(const std::string &personal_id, const std::string &password) {
    return uniffi::FfiConverterTypeLoginResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_fuboncore_dma_login,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterString::lower(personal_id), uniffi::FfiConverterString::lower(password)));
}
std::string FubonCore::exchange_realtime_token() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_fuboncore_exchange_realtime_token,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance));
}
SdkRef FubonCore::get_ref() {
    return uniffi::FfiConverterTypeSdkRef::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_fuboncore_get_ref,
        nullptr,
        this->instance));
}
void FubonCore::inner_register_callback(const std::shared_ptr<Callback> &callback) {
    uniffi::rust_call(
        uniffi_fubon_fn_method_fuboncore_inner_register_callback,
        nullptr,
        this->instance, uniffi::FfiConverterCallback::lower(callback));
}
LoginResponse FubonCore::login(const std::string &personal_id, const std::string &password, const std::string &cert_path, std::optional<std::string> cert_pass) {
    return uniffi::FfiConverterTypeLoginResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_fuboncore_login,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterString::lower(personal_id), uniffi::FfiConverterString::lower(password), uniffi::FfiConverterString::lower(cert_path), uniffi::FfiConverterOptionalString::lower(cert_pass)));
}
bool FubonCore::logout() {
    return uniffi::FfiConverterBool::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_fuboncore_logout,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance));
}
VecRecoverResponse FubonCore::recover_event_data() {
    return uniffi::FfiConverterTypeVecRecoverResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_fuboncore_recover_event_data,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance));
}

FubonCore::~FubonCore() {
    uniffi::rust_call(
        uniffi_fubon_fn_free_fuboncore,
        nullptr,
        this->instance
    );
}


FugleRealtime::FugleRealtime(void *ptr): instance(ptr) {}


std::shared_ptr<FugleRealtime> FugleRealtime::init() {
    return std::shared_ptr<FugleRealtime>(
        new FugleRealtime(uniffi::rust_call(
        uniffi_fubon_fn_constructor_fuglerealtime_new,
        nullptr))
    );
}

std::string FugleRealtime::fubon_ws_url() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_fuglerealtime_fubon_ws_url,
        nullptr,
        this->instance));
}
std::string FugleRealtime::realtime_rest_url() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_fuglerealtime_realtime_rest_url,
        nullptr,
        this->instance));
}
std::string FugleRealtime::realtime_ws_normal_url() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_fuglerealtime_realtime_ws_normal_url,
        nullptr,
        this->instance));
}
std::string FugleRealtime::realtime_ws_speed_url() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_fuglerealtime_realtime_ws_speed_url,
        nullptr,
        this->instance));
}

FugleRealtime::~FugleRealtime() {
    uniffi::rust_call(
        uniffi_fubon_fn_free_fuglerealtime,
        nullptr,
        this->instance
    );
}


FutOptAccounting::FutOptAccounting(void *ptr): instance(ptr) {}


VecCloseRecordResponse FutOptAccounting::close_position_record(const Account &account, const std::string &start_date, std::optional<std::string> end_date) {
    return uniffi::FfiConverterTypeVecCloseRecordResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptaccounting_close_position_record,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterOptionalString::lower(end_date)));
}
VecFutOptHybridPositionResponse FutOptAccounting::query_hybrid_position(const Account &account) {
    return uniffi::FfiConverterTypeVecFutOptHybridPositionResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptaccounting_query_hybrid_position,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account)));
}
VecEquityResponse FutOptAccounting::query_margin_equity(const Account &account) {
    return uniffi::FfiConverterTypeVecEquityResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptaccounting_query_margin_equity,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account)));
}
VecFutOptPositionResponse FutOptAccounting::query_single_position(const Account &account) {
    return uniffi::FfiConverterTypeVecFutOptPositionResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptaccounting_query_single_position,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account)));
}

FutOptAccounting::~FutOptAccounting() {
    uniffi::rust_call(
        uniffi_fubon_fn_free_futoptaccounting,
        nullptr,
        this->instance
    );
}


FutOptFunctions::FutOptFunctions(void *ptr): instance(ptr) {}


VecFutOptOrderResponse FutOptFunctions::batch_cancel_order(const Account &account, const std::vector<FutOptOrderResult> &orders) {
    return uniffi::FfiConverterTypeVecFutOptOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_batch_cancel_order,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterSequenceTypeFutOptOrderResult::lower(orders)));
}
VecFutOptOrderResponse FutOptFunctions::batch_modify_lot(const Account &account, const std::vector<FutOptModifyLot> &orders) {
    return uniffi::FfiConverterTypeVecFutOptOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_batch_modify_lot,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterSequenceTypeFutOptModifyLot::lower(orders)));
}
VecFutOptOrderResponse FutOptFunctions::batch_modify_price(const Account &account, const std::vector<FutOptModifyPrice> &orders) {
    return uniffi::FfiConverterTypeVecFutOptOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_batch_modify_price,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterSequenceTypeFutOptModifyPrice::lower(orders)));
}
VecFutOptOrderResponse FutOptFunctions::batch_order_detail(const Account &account, const BatchResult &batch) {
    return uniffi::FfiConverterTypeVecFutOptOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_batch_order_detail,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterTypeBatchResult::lower(batch)));
}
BatchResponse FutOptFunctions::batch_order_lists(const Account &account) {
    return uniffi::FfiConverterTypeBatchResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_batch_order_lists,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account)));
}
VecFutOptOrderResponse FutOptFunctions::batch_place_order(const Account &account, const std::vector<FutOptOrder> &orders) {
    return uniffi::FfiConverterTypeVecFutOptOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_batch_place_order,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterSequenceTypeFutOptOrder::lower(orders)));
}
StringResponse FutOptFunctions::cancel_condition_orders(const Account &account, const std::string &guid, std::optional<FutOptConditionMarketType> market_type) {
    return uniffi::FfiConverterTypeStringResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_cancel_condition_orders,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(guid), uniffi::FfiConverterOptionalTypeFutOptConditionMarketType::lower(market_type)));
}
FutOptOrderResponse FutOptFunctions::cancel_order(const Account &account, const FutOptOrderResult &order_res, std::optional<bool> unblock) {
    return uniffi::FfiConverterTypeFutOptOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_cancel_order,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterTypeFutOptOrderResult::lower(order_res), uniffi::FfiConverterOptionalBool::lower(unblock)));
}
std::string FutOptFunctions::convert_symbol(const std::string &stock_symbol, const std::string &expiry_date, std::optional<double> strike_price, std::optional<CallPut> call_put) {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_convert_symbol,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterString::lower(stock_symbol), uniffi::FfiConverterString::lower(expiry_date), uniffi::FfiConverterOptionalDouble::lower(strike_price), uniffi::FfiConverterOptionalTypeCallPut::lower(call_put)));
}
VecFutOptFilledResponse FutOptFunctions::filled_history(const Account &account, const FutOptMarketType &market_type, const std::string &start_date, std::optional<std::string> end_date) {
    return uniffi::FfiConverterTypeVecFutOptFilledResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_filled_history,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterTypeFutOptMarketType::lower(market_type), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterOptionalString::lower(end_date)));
}
VecConditionDetailResponse FutOptFunctions::get_condition_history(const Account &account, const std::string &start_date, const std::string &end_date, std::optional<FutOptConditionMarketType> market_type, std::optional<HistoryStatus> history_type) {
    return uniffi::FfiConverterTypeVecConditionDetailResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_get_condition_history,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterString::lower(end_date), uniffi::FfiConverterOptionalTypeFutOptConditionMarketType::lower(market_type), uniffi::FfiConverterOptionalTypeHistoryStatus::lower(history_type)));
}
VecConditionDetailResponse FutOptFunctions::get_condition_order(const Account &account, std::optional<FutOptConditionMarketType> market_type, std::optional<ConditionStatus> condition_status) {
    return uniffi::FfiConverterTypeVecConditionDetailResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_get_condition_order,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterOptionalTypeFutOptConditionMarketType::lower(market_type), uniffi::FfiConverterOptionalTypeConditionStatus::lower(condition_status)));
}
VecConditionDetailResponse FutOptFunctions::get_condition_order_by_id(const Account &account, const std::string &guid, std::optional<FutOptConditionMarketType> market_type) {
    return uniffi::FfiConverterTypeVecConditionDetailResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_get_condition_order_by_id,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(guid), uniffi::FfiConverterOptionalTypeFutOptConditionMarketType::lower(market_type)));
}
VecFutOptOrderResponse FutOptFunctions::get_order_results(const Account &account, std::optional<FutOptMarketType> market_type) {
    return uniffi::FfiConverterTypeVecFutOptOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_get_order_results,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterOptionalTypeFutOptMarketType::lower(market_type)));
}
VecFutOptOrderResponse FutOptFunctions::get_order_results_detail(const Account &account, std::optional<FutOptMarketType> market_type) {
    return uniffi::FfiConverterTypeVecFutOptOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_get_order_results_detail,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterOptionalTypeFutOptMarketType::lower(market_type)));
}
VecConditionDetailResponse FutOptFunctions::get_time_slice_order(const Account &account, const std::string &batch_no, std::optional<FutOptConditionMarketType> market_type) {
    return uniffi::FfiConverterTypeVecConditionDetailResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_get_time_slice_order,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(batch_no), uniffi::FfiConverterOptionalTypeFutOptConditionMarketType::lower(market_type)));
}
VecConditionDetailResponse FutOptFunctions::get_trail_history(const Account &account, const std::string &start_date, const std::string &end_date, std::optional<FutOptConditionMarketType> market_type) {
    return uniffi::FfiConverterTypeVecConditionDetailResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_get_trail_history,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterString::lower(end_date), uniffi::FfiConverterOptionalTypeFutOptConditionMarketType::lower(market_type)));
}
VecConditionDetailResponse FutOptFunctions::get_trail_order(const Account &account, std::optional<FutOptConditionMarketType> market_type) {
    return uniffi::FfiConverterTypeVecConditionDetailResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_get_trail_order,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterOptionalTypeFutOptConditionMarketType::lower(market_type)));
}
FutOptModifyLot FutOptFunctions::make_modify_lot_obj(const FutOptOrderResult &order, int64_t lot) {
    return uniffi::FfiConverterTypeFutOptModifyLot::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_make_modify_lot_obj,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeFutOptOrderResult::lower(order), uniffi::FfiConverterInt64::lower(lot)));
}
FutOptModifyPrice FutOptFunctions::make_modify_price_obj(const FutOptOrderResult &order, std::optional<std::string> price, std::optional<FutOptPriceType> price_type) {
    return uniffi::FfiConverterTypeFutOptModifyPrice::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_make_modify_price_obj,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeFutOptOrderResult::lower(order), uniffi::FfiConverterOptionalString::lower(price), uniffi::FfiConverterOptionalTypeFutOptPriceType::lower(price_type)));
}
FutOptOrderResponse FutOptFunctions::modify_lot(const Account &account, const FutOptModifyLot &modify_obj, std::optional<bool> unblock) {
    return uniffi::FfiConverterTypeFutOptOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_modify_lot,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterTypeFutOptModifyLot::lower(modify_obj), uniffi::FfiConverterOptionalBool::lower(unblock)));
}
FutOptOrderResponse FutOptFunctions::modify_price(const Account &account, const FutOptModifyPrice &modify_obj, std::optional<bool> unblock) {
    return uniffi::FfiConverterTypeFutOptOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_modify_price,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterTypeFutOptModifyPrice::lower(modify_obj), uniffi::FfiConverterOptionalBool::lower(unblock)));
}
ConditionOrderResultResponse FutOptFunctions::multi_condition(const Account &account, const std::string &start_date, const std::string &end_date, const StopSign &stop_sign, const std::vector<Condition> &conditions, const FutOptConditionOrder &order, std::optional<FutOptTPSLWrapper> child_info) {
    return uniffi::FfiConverterTypeConditionOrderResultResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_multi_condition,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterString::lower(end_date), uniffi::FfiConverterTypeStopSign::lower(stop_sign), uniffi::FfiConverterSequenceTypeCondition::lower(conditions), uniffi::FfiConverterTypeFutOptConditionOrder::lower(order), uniffi::FfiConverterOptionalTypeFutOptTPSLWrapper::lower(child_info)));
}
VecFutOptOrderResponse FutOptFunctions::order_history(const Account &account, const std::string &start_date, const std::string &end_date, std::optional<FutOptMarketType> market_type) {
    return uniffi::FfiConverterTypeVecFutOptOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_order_history,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterString::lower(end_date), uniffi::FfiConverterOptionalTypeFutOptMarketType::lower(market_type)));
}
FutOptOrderResponse FutOptFunctions::place_order(const Account &account, const FutOptOrder &order, std::optional<bool> unblock) {
    return uniffi::FfiConverterTypeFutOptOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_place_order,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterTypeFutOptOrder::lower(order), uniffi::FfiConverterOptionalBool::lower(unblock)));
}
EstimateMarginResponse FutOptFunctions::query_estimate_margin(const Account &account, const FutOptOrder &order) {
    return uniffi::FfiConverterTypeEstimateMarginResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_query_estimate_margin,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterTypeFutOptOrder::lower(order)));
}
ConditionOrderResultResponse FutOptFunctions::single_condition(const Account &account, const std::string &start_date, const std::string &end_date, const StopSign &stop_sign, const Condition &condition, const FutOptConditionOrder &order, std::optional<FutOptTPSLWrapper> child_info) {
    return uniffi::FfiConverterTypeConditionOrderResultResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_single_condition,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterString::lower(end_date), uniffi::FfiConverterTypeStopSign::lower(stop_sign), uniffi::FfiConverterTypeCondition::lower(condition), uniffi::FfiConverterTypeFutOptConditionOrder::lower(order), uniffi::FfiConverterOptionalTypeFutOptTPSLWrapper::lower(child_info)));
}
ConditionOrderResultResponse FutOptFunctions::time_slice_order(const Account &account, const std::string &start_date, const std::string &end_date, const StopSign &stop_sign, const SplitDescription &split_description, const FutOptConditionOrder &order) {
    return uniffi::FfiConverterTypeConditionOrderResultResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_time_slice_order,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterString::lower(end_date), uniffi::FfiConverterTypeStopSign::lower(stop_sign), uniffi::FfiConverterTypeSplitDescription::lower(split_description), uniffi::FfiConverterTypeFutOptConditionOrder::lower(order)));
}
ConditionOrderResultResponse FutOptFunctions::trail_profit(const Account &account, const std::string &start_date, const std::string &end_date, const StopSign &stop_sign, const FutOptTrailOrder &trail_order) {
    return uniffi::FfiConverterTypeConditionOrderResultResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_futoptfunctions_trail_profit,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterString::lower(end_date), uniffi::FfiConverterTypeStopSign::lower(stop_sign), uniffi::FfiConverterTypeFutOptTrailOrder::lower(trail_order)));
}

FutOptFunctions::~FutOptFunctions() {
    uniffi::rust_call(
        uniffi_fubon_fn_free_futoptfunctions,
        nullptr,
        this->instance
    );
}


StockFunctions::StockFunctions(void *ptr): instance(ptr) {}


VecOrderResponse StockFunctions::batch_cancel_order(const Account &account, const std::vector<OrderResult> &orders) {
    return uniffi::FfiConverterTypeVecOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_batch_cancel_order,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterSequenceTypeOrderResult::lower(orders)));
}
VecOrderResponse StockFunctions::batch_modify_price(const Account &account, const std::vector<ModifyPrice> &orders) {
    return uniffi::FfiConverterTypeVecOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_batch_modify_price,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterSequenceTypeModifyPrice::lower(orders)));
}
VecOrderResponse StockFunctions::batch_modify_quantity(const Account &account, const std::vector<ModifyQuantity> &orders) {
    return uniffi::FfiConverterTypeVecOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_batch_modify_quantity,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterSequenceTypeModifyQuantity::lower(orders)));
}
VecOrderResponse StockFunctions::batch_order_detail(const Account &account, const BatchResult &batch) {
    return uniffi::FfiConverterTypeVecOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_batch_order_detail,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterTypeBatchResult::lower(batch)));
}
BatchResponse StockFunctions::batch_order_lists(const Account &account) {
    return uniffi::FfiConverterTypeBatchResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_batch_order_lists,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account)));
}
VecOrderResponse StockFunctions::batch_place_order(const Account &account, const std::vector<Order> &orders) {
    return uniffi::FfiConverterTypeVecOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_batch_place_order,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterSequenceTypeOrder::lower(orders)));
}
StringResponse StockFunctions::cancel_condition_orders(const Account &account, const std::string &guid) {
    return uniffi::FfiConverterTypeStringResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_cancel_condition_orders,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(guid)));
}
OrderResponse StockFunctions::cancel_order(const Account &account, const OrderResult &order_res, std::optional<bool> unblock) {
    return uniffi::FfiConverterTypeOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_cancel_order,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterTypeOrderResult::lower(order_res), uniffi::FfiConverterOptionalBool::lower(unblock)));
}
DayTradeStockInfoResponse StockFunctions::daytrade_and_stock_info(const Account &account, const std::string &stock_no) {
    return uniffi::FfiConverterTypeDayTradeStockInfoResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_daytrade_and_stock_info,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(stock_no)));
}
FilledResponse StockFunctions::filled_history(const Account &account, std::optional<std::string> start_date, std::optional<std::string> end_date) {
    return uniffi::FfiConverterTypeFilledResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_filled_history,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterOptionalString::lower(start_date), uniffi::FfiConverterOptionalString::lower(end_date)));
}
VecConditionDetailResponse StockFunctions::get_condition_daytrade_by_id(const Account &account, const std::string &guid) {
    return uniffi::FfiConverterTypeVecConditionDetailResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_get_condition_daytrade_by_id,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(guid)));
}
VecConditionDetailResponse StockFunctions::get_condition_history(const Account &account, const std::string &start_date, const std::string &end_date, std::optional<HistoryStatus> history_type) {
    return uniffi::FfiConverterTypeVecConditionDetailResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_get_condition_history,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterString::lower(end_date), uniffi::FfiConverterOptionalTypeHistoryStatus::lower(history_type)));
}
VecConditionDetailResponse StockFunctions::get_condition_order(const Account &account, std::optional<ConditionStatus> condition_status) {
    return uniffi::FfiConverterTypeVecConditionDetailResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_get_condition_order,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterOptionalTypeConditionStatus::lower(condition_status)));
}
VecConditionDetailResponse StockFunctions::get_condition_order_by_id(const Account &account, const std::string &guid) {
    return uniffi::FfiConverterTypeVecConditionDetailResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_get_condition_order_by_id,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(guid)));
}
VecOrderResponse StockFunctions::get_order_results(const Account &account) {
    return uniffi::FfiConverterTypeVecOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_get_order_results,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account)));
}
VecOrderResponse StockFunctions::get_order_results_detail(const Account &account) {
    return uniffi::FfiConverterTypeVecOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_get_order_results_detail,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account)));
}
VecConditionDetailResponse StockFunctions::get_time_slice_order(const Account &account, const std::string &batch_no) {
    return uniffi::FfiConverterTypeVecConditionDetailResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_get_time_slice_order,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(batch_no)));
}
VecConditionDetailResponse StockFunctions::get_trail_history(const Account &account, const std::string &start_date, const std::string &end_date) {
    return uniffi::FfiConverterTypeVecConditionDetailResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_get_trail_history,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterString::lower(end_date)));
}
VecConditionDetailResponse StockFunctions::get_trail_order(const Account &account) {
    return uniffi::FfiConverterTypeVecConditionDetailResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_get_trail_order,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account)));
}
ModifyPrice StockFunctions::make_modify_price_obj(const OrderResult &order, std::optional<std::string> price, std::optional<PriceType> price_type) {
    return uniffi::FfiConverterTypeModifyPrice::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_make_modify_price_obj,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeOrderResult::lower(order), uniffi::FfiConverterOptionalString::lower(price), uniffi::FfiConverterOptionalTypePriceType::lower(price_type)));
}
ModifyQuantity StockFunctions::make_modify_quantity_obj(const OrderResult &order, int64_t quantity) {
    return uniffi::FfiConverterTypeModifyQuantity::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_make_modify_quantity_obj,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeOrderResult::lower(order), uniffi::FfiConverterInt64::lower(quantity)));
}
MarginShortQuotaResponse StockFunctions::margin_quota(const Account &account, const std::string &stock_no) {
    return uniffi::FfiConverterTypeMarginShortQuotaResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_margin_quota,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(stock_no)));
}
OrderResponse StockFunctions::modify_price(const Account &account, const ModifyPrice &modify_obj, std::optional<bool> unblock) {
    return uniffi::FfiConverterTypeOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_modify_price,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterTypeModifyPrice::lower(modify_obj), uniffi::FfiConverterOptionalBool::lower(unblock)));
}
OrderResponse StockFunctions::modify_quantity(const Account &account, const ModifyQuantity &modify_obj, std::optional<bool> unblock) {
    return uniffi::FfiConverterTypeOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_modify_quantity,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterTypeModifyQuantity::lower(modify_obj), uniffi::FfiConverterOptionalBool::lower(unblock)));
}
ConditionOrderResultResponse StockFunctions::multi_condition(const Account &account, const std::string &start_date, const std::string &end_date, const StopSign &stop_sign, const std::vector<Condition> &conditions, const ConditionOrder &order, std::optional<TPSLWrapper> child_info) {
    return uniffi::FfiConverterTypeConditionOrderResultResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_multi_condition,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterString::lower(end_date), uniffi::FfiConverterTypeStopSign::lower(stop_sign), uniffi::FfiConverterSequenceTypeCondition::lower(conditions), uniffi::FfiConverterTypeConditionOrder::lower(order), uniffi::FfiConverterOptionalTypeTPSLWrapper::lower(child_info)));
}
ConditionOrderResultResponse StockFunctions::multi_condition_day_trade(const Account &account, const StopSign &stop_sign, const std::string &end_time, const std::vector<Condition> &conditions, const ConditionOrder &order, const ConditionDayTrade &condition_day_trade, std::optional<TPSLWrapper> child_info, std::optional<bool> fix_session) {
    return uniffi::FfiConverterTypeConditionOrderResultResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_multi_condition_day_trade,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterTypeStopSign::lower(stop_sign), uniffi::FfiConverterString::lower(end_time), uniffi::FfiConverterSequenceTypeCondition::lower(conditions), uniffi::FfiConverterTypeConditionOrder::lower(order), uniffi::FfiConverterTypeConditionDayTrade::lower(condition_day_trade), uniffi::FfiConverterOptionalTypeTPSLWrapper::lower(child_info), uniffi::FfiConverterOptionalBool::lower(fix_session)));
}
ConditionOrderResultResponse StockFunctions::multi_condition_stop(const Account &account, const std::string &start_date, const std::string &end_date, const StopSign &stop_sign, const std::vector<Condition> &conditions, const ConditionOrder &order, const std::vector<Condition> &stop_conditions, std::optional<std::vector<Condition>> second_stop_conditions, std::optional<TPSLWrapper> child_info) {
    return uniffi::FfiConverterTypeConditionOrderResultResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_multi_condition_stop,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterString::lower(end_date), uniffi::FfiConverterTypeStopSign::lower(stop_sign), uniffi::FfiConverterSequenceTypeCondition::lower(conditions), uniffi::FfiConverterTypeConditionOrder::lower(order), uniffi::FfiConverterSequenceTypeCondition::lower(stop_conditions), uniffi::FfiConverterOptionalSequenceTypeCondition::lower(second_stop_conditions), uniffi::FfiConverterOptionalTypeTPSLWrapper::lower(child_info)));
}
VecOrderResponse StockFunctions::order_history(const Account &account, const std::string &start_date, std::optional<std::string> end_date) {
    return uniffi::FfiConverterTypeVecOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_order_history,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterOptionalString::lower(end_date)));
}
OrderResponse StockFunctions::place_order(const Account &account, const Order &order, std::optional<bool> unblock) {
    return uniffi::FfiConverterTypeOrderResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_place_order,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterTypeOrder::lower(order), uniffi::FfiConverterOptionalBool::lower(unblock)));
}
SymbolQuoteResponse StockFunctions::query_symbol_quote(const Account &account, const std::string &symbol, std::optional<MarketType> market_type) {
    return uniffi::FfiConverterTypeSymbolQuoteResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_query_symbol_quote,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(symbol), uniffi::FfiConverterOptionalTypeMarketType::lower(market_type)));
}
VecSymbolQuoteResponse StockFunctions::query_symbol_snapshot(const Account &account, std::optional<MarketType> market_type, std::optional<std::vector<StockType>> stock_types) {
    return uniffi::FfiConverterTypeVecSymbolQuoteResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_query_symbol_snapshot,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterOptionalTypeMarketType::lower(market_type), uniffi::FfiConverterOptionalSequenceTypeStockType::lower(stock_types)));
}
ConditionOrderResultResponse StockFunctions::single_condition(const Account &account, const std::string &start_date, const std::string &end_date, const StopSign &stop_sign, const Condition &condition, const ConditionOrder &order, std::optional<TPSLWrapper> child_info) {
    return uniffi::FfiConverterTypeConditionOrderResultResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_single_condition,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterString::lower(end_date), uniffi::FfiConverterTypeStopSign::lower(stop_sign), uniffi::FfiConverterTypeCondition::lower(condition), uniffi::FfiConverterTypeConditionOrder::lower(order), uniffi::FfiConverterOptionalTypeTPSLWrapper::lower(child_info)));
}
ConditionOrderResultResponse StockFunctions::single_condition_day_trade(const Account &account, const StopSign &stop_sign, const std::string &end_time, const Condition &condition, const ConditionOrder &order, const ConditionDayTrade &condition_day_trade, std::optional<TPSLWrapper> child_info, std::optional<bool> fix_session) {
    return uniffi::FfiConverterTypeConditionOrderResultResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_single_condition_day_trade,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterTypeStopSign::lower(stop_sign), uniffi::FfiConverterString::lower(end_time), uniffi::FfiConverterTypeCondition::lower(condition), uniffi::FfiConverterTypeConditionOrder::lower(order), uniffi::FfiConverterTypeConditionDayTrade::lower(condition_day_trade), uniffi::FfiConverterOptionalTypeTPSLWrapper::lower(child_info), uniffi::FfiConverterOptionalBool::lower(fix_session)));
}
ConditionOrderResultResponse StockFunctions::single_condition_stop(const Account &account, const std::string &start_date, const std::string &end_date, const StopSign &stop_sign, const Condition &condition, const ConditionOrder &order, const std::vector<Condition> &stop_conditions, std::optional<std::vector<Condition>> second_stop_conditions, std::optional<TPSLWrapper> child_info) {
    return uniffi::FfiConverterTypeConditionOrderResultResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_single_condition_stop,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterString::lower(end_date), uniffi::FfiConverterTypeStopSign::lower(stop_sign), uniffi::FfiConverterTypeCondition::lower(condition), uniffi::FfiConverterTypeConditionOrder::lower(order), uniffi::FfiConverterSequenceTypeCondition::lower(stop_conditions), uniffi::FfiConverterOptionalSequenceTypeCondition::lower(second_stop_conditions), uniffi::FfiConverterOptionalTypeTPSLWrapper::lower(child_info)));
}
ConditionOrderResultResponse StockFunctions::time_slice_order(const Account &account, const std::string &start_date, const std::string &end_date, const StopSign &stop_sign, const SplitDescription &split_description, const ConditionOrder &order) {
    return uniffi::FfiConverterTypeConditionOrderResultResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_time_slice_order,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterString::lower(end_date), uniffi::FfiConverterTypeStopSign::lower(stop_sign), uniffi::FfiConverterTypeSplitDescription::lower(split_description), uniffi::FfiConverterTypeConditionOrder::lower(order)));
}
ConditionOrderResultResponse StockFunctions::trail_profit(const Account &account, const std::string &start_date, const std::string &end_date, const StopSign &stop_sign, const TrailOrder &trail_order) {
    return uniffi::FfiConverterTypeConditionOrderResultResponse::lift(uniffi::rust_call(
        uniffi_fubon_fn_method_stockfunctions_trail_profit,
        uniffi::FfiConverterTypeFubonError::lift,
        this->instance, uniffi::FfiConverterTypeAccount::lower(account), uniffi::FfiConverterString::lower(start_date), uniffi::FfiConverterString::lower(end_date), uniffi::FfiConverterTypeStopSign::lower(stop_sign), uniffi::FfiConverterTypeTrailOrder::lower(trail_order)));
}

StockFunctions::~StockFunctions() {
    uniffi::rust_call(
        uniffi_fubon_fn_free_stockfunctions,
        nullptr,
        this->instance
    );
}





































































































































































































namespace uniffi {






std::shared_ptr<Accounting> FfiConverterAccounting::lift(void *ptr) {
    return std::shared_ptr<Accounting>(new Accounting(ptr));
}

void *FfiConverterAccounting::lower(const std::shared_ptr<Accounting> &obj) {
    return obj->instance;
}

std::shared_ptr<Accounting> FfiConverterAccounting::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<Accounting>(new Accounting(reinterpret_cast<void *>(ptr)));
}

void FfiConverterAccounting::write(RustStream &stream, const std::shared_ptr<Accounting> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterAccounting::allocation_size(const std::shared_ptr<Accounting> &) {
    return 8;
}

std::shared_ptr<FubonCore> FfiConverterFubonCore::lift(void *ptr) {
    return std::shared_ptr<FubonCore>(new FubonCore(ptr));
}

void *FfiConverterFubonCore::lower(const std::shared_ptr<FubonCore> &obj) {
    return obj->instance;
}

std::shared_ptr<FubonCore> FfiConverterFubonCore::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<FubonCore>(new FubonCore(reinterpret_cast<void *>(ptr)));
}

void FfiConverterFubonCore::write(RustStream &stream, const std::shared_ptr<FubonCore> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterFubonCore::allocation_size(const std::shared_ptr<FubonCore> &) {
    return 8;
}

std::shared_ptr<FugleRealtime> FfiConverterFugleRealtime::lift(void *ptr) {
    return std::shared_ptr<FugleRealtime>(new FugleRealtime(ptr));
}

void *FfiConverterFugleRealtime::lower(const std::shared_ptr<FugleRealtime> &obj) {
    return obj->instance;
}

std::shared_ptr<FugleRealtime> FfiConverterFugleRealtime::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<FugleRealtime>(new FugleRealtime(reinterpret_cast<void *>(ptr)));
}

void FfiConverterFugleRealtime::write(RustStream &stream, const std::shared_ptr<FugleRealtime> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterFugleRealtime::allocation_size(const std::shared_ptr<FugleRealtime> &) {
    return 8;
}

std::shared_ptr<FutOptAccounting> FfiConverterFutOptAccounting::lift(void *ptr) {
    return std::shared_ptr<FutOptAccounting>(new FutOptAccounting(ptr));
}

void *FfiConverterFutOptAccounting::lower(const std::shared_ptr<FutOptAccounting> &obj) {
    return obj->instance;
}

std::shared_ptr<FutOptAccounting> FfiConverterFutOptAccounting::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<FutOptAccounting>(new FutOptAccounting(reinterpret_cast<void *>(ptr)));
}

void FfiConverterFutOptAccounting::write(RustStream &stream, const std::shared_ptr<FutOptAccounting> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterFutOptAccounting::allocation_size(const std::shared_ptr<FutOptAccounting> &) {
    return 8;
}

std::shared_ptr<FutOptFunctions> FfiConverterFutOptFunctions::lift(void *ptr) {
    return std::shared_ptr<FutOptFunctions>(new FutOptFunctions(ptr));
}

void *FfiConverterFutOptFunctions::lower(const std::shared_ptr<FutOptFunctions> &obj) {
    return obj->instance;
}

std::shared_ptr<FutOptFunctions> FfiConverterFutOptFunctions::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<FutOptFunctions>(new FutOptFunctions(reinterpret_cast<void *>(ptr)));
}

void FfiConverterFutOptFunctions::write(RustStream &stream, const std::shared_ptr<FutOptFunctions> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterFutOptFunctions::allocation_size(const std::shared_ptr<FutOptFunctions> &) {
    return 8;
}

std::shared_ptr<StockFunctions> FfiConverterStockFunctions::lift(void *ptr) {
    return std::shared_ptr<StockFunctions>(new StockFunctions(ptr));
}

void *FfiConverterStockFunctions::lower(const std::shared_ptr<StockFunctions> &obj) {
    return obj->instance;
}

std::shared_ptr<StockFunctions> FfiConverterStockFunctions::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<StockFunctions>(new StockFunctions(reinterpret_cast<void *>(ptr)));
}

void FfiConverterStockFunctions::write(RustStream &stream, const std::shared_ptr<StockFunctions> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterStockFunctions::allocation_size(const std::shared_ptr<StockFunctions> &) {
    return 8;
}


Account FfiConverterTypeAccount::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeAccount::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeAccount::lower(const Account &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeAccount::write(stream, val);

    return std::move(buf);
}

Account FfiConverterTypeAccount::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream)
    };
}

void FfiConverterTypeAccount::write(RustStream &stream, const Account &val) {
    FfiConverterString::write(stream, val.name);
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.account);
    FfiConverterString::write(stream, val.account_type);
}

int32_t FfiConverterTypeAccount::allocation_size(const Account &val) {
    
    return 
        FfiConverterString::allocation_size(val.name) +
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterString::allocation_size(val.account_type);
    
}


AccountRes FfiConverterTypeAccountRes::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeAccountRes::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeAccountRes::lower(const AccountRes &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeAccountRes::write(stream, val);

    return std::move(buf);
}

AccountRes FfiConverterTypeAccountRes::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream)
    };
}

void FfiConverterTypeAccountRes::write(RustStream &stream, const AccountRes &val) {
    FfiConverterString::write(stream, val.account);
    FfiConverterString::write(stream, val.branch_no);
}

int32_t FfiConverterTypeAccountRes::allocation_size(const AccountRes &val) {
    
    return 
        FfiConverterString::allocation_size(val.account) +
        FfiConverterString::allocation_size(val.branch_no);
    
}


BankRemain FfiConverterTypeBankRemain::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeBankRemain::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeBankRemain::lower(const BankRemain &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeBankRemain::write(stream, val);

    return std::move(buf);
}

BankRemain FfiConverterTypeBankRemain::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterInt64::read(stream),
        FfiConverterInt64::read(stream)
    };
}

void FfiConverterTypeBankRemain::write(RustStream &stream, const BankRemain &val) {
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.account);
    FfiConverterString::write(stream, val.currency);
    FfiConverterInt64::write(stream, val.balance);
    FfiConverterInt64::write(stream, val.available_balance);
}

int32_t FfiConverterTypeBankRemain::allocation_size(const BankRemain &val) {
    
    return 
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterString::allocation_size(val.currency) +
        FfiConverterInt64::allocation_size(val.balance) +
        FfiConverterInt64::allocation_size(val.available_balance);
    
}


BankRemainResponse FfiConverterTypeBankRemainResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeBankRemainResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeBankRemainResponse::lower(const BankRemainResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeBankRemainResponse::write(stream, val);

    return std::move(buf);
}

BankRemainResponse FfiConverterTypeBankRemainResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalTypeBankRemain::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeBankRemainResponse::write(RustStream &stream, const BankRemainResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalTypeBankRemain::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeBankRemainResponse::allocation_size(const BankRemainResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalTypeBankRemain::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


BatchResponse FfiConverterTypeBatchResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeBatchResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeBatchResponse::lower(const BatchResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeBatchResponse::write(stream, val);

    return std::move(buf);
}

BatchResponse FfiConverterTypeBatchResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalSequenceTypeBatchResult::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeBatchResponse::write(RustStream &stream, const BatchResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalSequenceTypeBatchResult::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeBatchResponse::allocation_size(const BatchResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalSequenceTypeBatchResult::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


BatchResult FfiConverterTypeBatchResult::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeBatchResult::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeBatchResult::lower(const BatchResult &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeBatchResult::write(stream, val);

    return std::move(buf);
}

BatchResult FfiConverterTypeBatchResult::read(RustStream &stream) {
    return {
        FfiConverterInt32::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream)
    };
}

void FfiConverterTypeBatchResult::write(RustStream &stream, const BatchResult &val) {
    FfiConverterInt32::write(stream, val.function_type);
    FfiConverterString::write(stream, val.date);
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.account);
    FfiConverterString::write(stream, val.batch_seq_no);
}

int32_t FfiConverterTypeBatchResult::allocation_size(const BatchResult &val) {
    
    return 
        FfiConverterInt32::allocation_size(val.function_type) +
        FfiConverterString::allocation_size(val.date) +
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterString::allocation_size(val.batch_seq_no);
    
}


CancelResult FfiConverterTypeCancelResult::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeCancelResult::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeCancelResult::lower(const CancelResult &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeCancelResult::write(stream, val);

    return std::move(buf);
}

CancelResult FfiConverterTypeCancelResult::read(RustStream &stream) {
    return {
        FfiConverterTypeReply::read(stream)
    };
}

void FfiConverterTypeCancelResult::write(RustStream &stream, const CancelResult &val) {
    FfiConverterTypeReply::write(stream, val.reply);
}

int32_t FfiConverterTypeCancelResult::allocation_size(const CancelResult &val) {
    
    return 
        FfiConverterTypeReply::allocation_size(val.reply);
    
}


CloseRecord FfiConverterTypeCloseRecord::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeCloseRecord::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeCloseRecord::lower(const CloseRecord &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeCloseRecord::write(stream, val);

    return std::move(buf);
}

CloseRecord FfiConverterTypeCloseRecord::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeFutOptOrderType::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalTypeCallPut::read(stream),
        FfiConverterTypeBSAction::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalDouble::read(stream)
    };
}

void FfiConverterTypeCloseRecord::write(RustStream &stream, const CloseRecord &val) {
    FfiConverterString::write(stream, val.date);
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.account);
    FfiConverterInt32::write(stream, val.position_kind);
    FfiConverterString::write(stream, val.order_no);
    FfiConverterTypeFutOptOrderType::write(stream, val.order_type);
    FfiConverterString::write(stream, val.market);
    FfiConverterString::write(stream, val.symbol);
    FfiConverterString::write(stream, val.expiry_date);
    FfiConverterOptionalDouble::write(stream, val.strike_price);
    FfiConverterOptionalTypeCallPut::write(stream, val.call_put);
    FfiConverterTypeBSAction::write(stream, val.buy_sell);
    FfiConverterDouble::write(stream, val.price);
    FfiConverterInt32::write(stream, val.orig_lots);
    FfiConverterOptionalDouble::write(stream, val.transaction_fee);
    FfiConverterOptionalDouble::write(stream, val.tax);
}

int32_t FfiConverterTypeCloseRecord::allocation_size(const CloseRecord &val) {
    
    return 
        FfiConverterString::allocation_size(val.date) +
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterInt32::allocation_size(val.position_kind) +
        FfiConverterString::allocation_size(val.order_no) +
        FfiConverterTypeFutOptOrderType::allocation_size(val.order_type) +
        FfiConverterString::allocation_size(val.market) +
        FfiConverterString::allocation_size(val.symbol) +
        FfiConverterString::allocation_size(val.expiry_date) +
        FfiConverterOptionalDouble::allocation_size(val.strike_price) +
        FfiConverterOptionalTypeCallPut::allocation_size(val.call_put) +
        FfiConverterTypeBSAction::allocation_size(val.buy_sell) +
        FfiConverterDouble::allocation_size(val.price) +
        FfiConverterInt32::allocation_size(val.orig_lots) +
        FfiConverterOptionalDouble::allocation_size(val.transaction_fee) +
        FfiConverterOptionalDouble::allocation_size(val.tax);
    
}


Condition FfiConverterTypeCondition::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeCondition::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeCondition::lower(const Condition &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeCondition::write(stream, val);

    return std::move(buf);
}

Condition FfiConverterTypeCondition::read(RustStream &stream) {
    return {
        FfiConverterTypeTradingType::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeTriggerContent::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeOperator::read(stream)
    };
}

void FfiConverterTypeCondition::write(RustStream &stream, const Condition &val) {
    FfiConverterTypeTradingType::write(stream, val.market_type);
    FfiConverterString::write(stream, val.symbol);
    FfiConverterTypeTriggerContent::write(stream, val.trigger);
    FfiConverterString::write(stream, val.trigger_value);
    FfiConverterTypeOperator::write(stream, val.comparison);
}

int32_t FfiConverterTypeCondition::allocation_size(const Condition &val) {
    
    return 
        FfiConverterTypeTradingType::allocation_size(val.market_type) +
        FfiConverterString::allocation_size(val.symbol) +
        FfiConverterTypeTriggerContent::allocation_size(val.trigger) +
        FfiConverterString::allocation_size(val.trigger_value) +
        FfiConverterTypeOperator::allocation_size(val.comparison);
    
}


ConditionDayTrade FfiConverterTypeConditionDayTrade::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeConditionDayTrade::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeConditionDayTrade::lower(const ConditionDayTrade &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeConditionDayTrade::write(stream, val);

    return std::move(buf);
}

ConditionDayTrade FfiConverterTypeConditionDayTrade::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterBool::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterTypeConditionPriceType::read(stream)
    };
}

void FfiConverterTypeConditionDayTrade::write(RustStream &stream, const ConditionDayTrade &val) {
    FfiConverterString::write(stream, val.day_trade_end_time);
    FfiConverterBool::write(stream, val.auto_cancel);
    FfiConverterOptionalString::write(stream, val.price);
    FfiConverterTypeConditionPriceType::write(stream, val.price_type);
}

int32_t FfiConverterTypeConditionDayTrade::allocation_size(const ConditionDayTrade &val) {
    
    return 
        FfiConverterString::allocation_size(val.day_trade_end_time) +
        FfiConverterBool::allocation_size(val.auto_cancel) +
        FfiConverterOptionalString::allocation_size(val.price) +
        FfiConverterTypeConditionPriceType::allocation_size(val.price_type);
    
}


ConditionDetail FfiConverterTypeConditionDetail::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeConditionDetail::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeConditionDetail::lower(const ConditionDetail &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeConditionDetail::write(stream, val);

    return std::move(buf);
}

ConditionDetail FfiConverterTypeConditionDetail::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterSequenceTypeParentChildRecord::read(stream),
        FfiConverterSequenceTypeParentChildRecord::read(stream)
    };
}

void FfiConverterTypeConditionDetail::write(RustStream &stream, const ConditionDetail &val) {
    FfiConverterString::write(stream, val.guid);
    FfiConverterString::write(stream, val.batch_no);
    FfiConverterString::write(stream, val.order_level);
    FfiConverterString::write(stream, val.last_time);
    FfiConverterOptionalString::write(stream, val.condition_type);
    FfiConverterOptionalString::write(stream, val.parent_guid);
    FfiConverterString::write(stream, val.symbol);
    FfiConverterString::write(stream, val.order_amount);
    FfiConverterString::write(stream, val.child_batch_no);
    FfiConverterString::write(stream, val.account);
    FfiConverterString::write(stream, val.condition_content);
    FfiConverterString::write(stream, val.action);
    FfiConverterString::write(stream, val.condition_buy_sell);
    FfiConverterString::write(stream, val.condition_symbol);
    FfiConverterString::write(stream, val.condition_price);
    FfiConverterString::write(stream, val.condition_volume);
    FfiConverterString::write(stream, val.condition_filled_volume);
    FfiConverterString::write(stream, val.create_time);
    FfiConverterString::write(stream, val.start_date);
    FfiConverterString::write(stream, val.status);
    FfiConverterOptionalString::write(stream, val.error_message);
    FfiConverterString::write(stream, val.detail_records_count);
    FfiConverterString::write(stream, val.tpsl_count);
    FfiConverterSequenceTypeParentChildRecord::write(stream, val.detail_records);
    FfiConverterSequenceTypeParentChildRecord::write(stream, val.tpsl_record);
}

int32_t FfiConverterTypeConditionDetail::allocation_size(const ConditionDetail &val) {
    
    return 
        FfiConverterString::allocation_size(val.guid) +
        FfiConverterString::allocation_size(val.batch_no) +
        FfiConverterString::allocation_size(val.order_level) +
        FfiConverterString::allocation_size(val.last_time) +
        FfiConverterOptionalString::allocation_size(val.condition_type) +
        FfiConverterOptionalString::allocation_size(val.parent_guid) +
        FfiConverterString::allocation_size(val.symbol) +
        FfiConverterString::allocation_size(val.order_amount) +
        FfiConverterString::allocation_size(val.child_batch_no) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterString::allocation_size(val.condition_content) +
        FfiConverterString::allocation_size(val.action) +
        FfiConverterString::allocation_size(val.condition_buy_sell) +
        FfiConverterString::allocation_size(val.condition_symbol) +
        FfiConverterString::allocation_size(val.condition_price) +
        FfiConverterString::allocation_size(val.condition_volume) +
        FfiConverterString::allocation_size(val.condition_filled_volume) +
        FfiConverterString::allocation_size(val.create_time) +
        FfiConverterString::allocation_size(val.start_date) +
        FfiConverterString::allocation_size(val.status) +
        FfiConverterOptionalString::allocation_size(val.error_message) +
        FfiConverterString::allocation_size(val.detail_records_count) +
        FfiConverterString::allocation_size(val.tpsl_count) +
        FfiConverterSequenceTypeParentChildRecord::allocation_size(val.detail_records) +
        FfiConverterSequenceTypeParentChildRecord::allocation_size(val.tpsl_record);
    
}


ConditionDetailResult FfiConverterTypeConditionDetailResult::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeConditionDetailResult::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeConditionDetailResult::lower(const ConditionDetailResult &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeConditionDetailResult::write(stream, val);

    return std::move(buf);
}

ConditionDetailResult FfiConverterTypeConditionDetailResult::read(RustStream &stream) {
    return {
        FfiConverterOptionalSequenceTypeConditionDetail::read(stream),
        FfiConverterTypeReply::read(stream)
    };
}

void FfiConverterTypeConditionDetailResult::write(RustStream &stream, const ConditionDetailResult &val) {
    FfiConverterOptionalSequenceTypeConditionDetail::write(stream, val.responses);
    FfiConverterTypeReply::write(stream, val.reply);
}

int32_t FfiConverterTypeConditionDetailResult::allocation_size(const ConditionDetailResult &val) {
    
    return 
        FfiConverterOptionalSequenceTypeConditionDetail::allocation_size(val.responses) +
        FfiConverterTypeReply::allocation_size(val.reply);
    
}


ConditionOrder FfiConverterTypeConditionOrder::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeConditionOrder::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeConditionOrder::lower(const ConditionOrder &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeConditionOrder::write(stream, val);

    return std::move(buf);
}

ConditionOrder FfiConverterTypeConditionOrder::read(RustStream &stream) {
    return {
        FfiConverterTypeBSAction::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterInt64::read(stream),
        FfiConverterTypeConditionMarketType::read(stream),
        FfiConverterTypeConditionPriceType::read(stream),
        FfiConverterTypeTimeInForce::read(stream),
        FfiConverterTypeConditionOrderType::read(stream)
    };
}

void FfiConverterTypeConditionOrder::write(RustStream &stream, const ConditionOrder &val) {
    FfiConverterTypeBSAction::write(stream, val.buy_sell);
    FfiConverterString::write(stream, val.symbol);
    FfiConverterOptionalString::write(stream, val.price);
    FfiConverterInt64::write(stream, val.quantity);
    FfiConverterTypeConditionMarketType::write(stream, val.market_type);
    FfiConverterTypeConditionPriceType::write(stream, val.price_type);
    FfiConverterTypeTimeInForce::write(stream, val.time_in_force);
    FfiConverterTypeConditionOrderType::write(stream, val.order_type);
}

int32_t FfiConverterTypeConditionOrder::allocation_size(const ConditionOrder &val) {
    
    return 
        FfiConverterTypeBSAction::allocation_size(val.buy_sell) +
        FfiConverterString::allocation_size(val.symbol) +
        FfiConverterOptionalString::allocation_size(val.price) +
        FfiConverterInt64::allocation_size(val.quantity) +
        FfiConverterTypeConditionMarketType::allocation_size(val.market_type) +
        FfiConverterTypeConditionPriceType::allocation_size(val.price_type) +
        FfiConverterTypeTimeInForce::allocation_size(val.time_in_force) +
        FfiConverterTypeConditionOrderType::allocation_size(val.order_type);
    
}


ConditionOrderResult FfiConverterTypeConditionOrderResult::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeConditionOrderResult::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeConditionOrderResult::lower(const ConditionOrderResult &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeConditionOrderResult::write(stream, val);

    return std::move(buf);
}

ConditionOrderResult FfiConverterTypeConditionOrderResult::read(RustStream &stream) {
    return {
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeConditionOrderResult::write(RustStream &stream, const ConditionOrderResult &val) {
    FfiConverterOptionalString::write(stream, val.guid);
}

int32_t FfiConverterTypeConditionOrderResult::allocation_size(const ConditionOrderResult &val) {
    
    return 
        FfiConverterOptionalString::allocation_size(val.guid);
    
}


ConditionOrderResultResponse FfiConverterTypeConditionOrderResultResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeConditionOrderResultResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeConditionOrderResultResponse::lower(const ConditionOrderResultResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeConditionOrderResultResponse::write(stream, val);

    return std::move(buf);
}

ConditionOrderResultResponse FfiConverterTypeConditionOrderResultResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalTypeConditionOrderResult::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeConditionOrderResultResponse::write(RustStream &stream, const ConditionOrderResultResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalTypeConditionOrderResult::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeConditionOrderResultResponse::allocation_size(const ConditionOrderResultResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalTypeConditionOrderResult::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


ConditionResult FfiConverterTypeConditionResult::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeConditionResult::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeConditionResult::lower(const ConditionResult &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeConditionResult::write(stream, val);

    return std::move(buf);
}

ConditionResult FfiConverterTypeConditionResult::read(RustStream &stream) {
    return {
        FfiConverterTypeConditionOrderResult::read(stream),
        FfiConverterTypeReply::read(stream)
    };
}

void FfiConverterTypeConditionResult::write(RustStream &stream, const ConditionResult &val) {
    FfiConverterTypeConditionOrderResult::write(stream, val.smart_order_response);
    FfiConverterTypeReply::write(stream, val.reply);
}

int32_t FfiConverterTypeConditionResult::allocation_size(const ConditionResult &val) {
    
    return 
        FfiConverterTypeConditionOrderResult::allocation_size(val.smart_order_response) +
        FfiConverterTypeReply::allocation_size(val.reply);
    
}


DayTradeStockInfo FfiConverterTypeDayTradeStockInfo::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeDayTradeStockInfo::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeDayTradeStockInfo::lower(const DayTradeStockInfo &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeDayTradeStockInfo::write(stream, val);

    return std::move(buf);
}

DayTradeStockInfo FfiConverterTypeDayTradeStockInfo::read(RustStream &stream) {
    return {
        FfiConverterOptionalString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt32::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeDayTradeStockInfo::write(RustStream &stream, const DayTradeStockInfo &val) {
    FfiConverterOptionalString::write(stream, val.stock_no);
    FfiConverterString::write(stream, val.date);
    FfiConverterOptionalInt64::write(stream, val.daytrade_orig_quota);
    FfiConverterOptionalInt64::write(stream, val.daytrade_tradable_quota);
    FfiConverterOptionalInt64::write(stream, val.precollect_single);
    FfiConverterOptionalInt64::write(stream, val.precollect_accumulate);
    FfiConverterOptionalInt32::write(stream, val.status);
    FfiConverterOptionalString::write(stream, val.disposition_status);
}

int32_t FfiConverterTypeDayTradeStockInfo::allocation_size(const DayTradeStockInfo &val) {
    
    return 
        FfiConverterOptionalString::allocation_size(val.stock_no) +
        FfiConverterString::allocation_size(val.date) +
        FfiConverterOptionalInt64::allocation_size(val.daytrade_orig_quota) +
        FfiConverterOptionalInt64::allocation_size(val.daytrade_tradable_quota) +
        FfiConverterOptionalInt64::allocation_size(val.precollect_single) +
        FfiConverterOptionalInt64::allocation_size(val.precollect_accumulate) +
        FfiConverterOptionalInt32::allocation_size(val.status) +
        FfiConverterOptionalString::allocation_size(val.disposition_status);
    
}


DayTradeStockInfoResponse FfiConverterTypeDayTradeStockInfoResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeDayTradeStockInfoResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeDayTradeStockInfoResponse::lower(const DayTradeStockInfoResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeDayTradeStockInfoResponse::write(stream, val);

    return std::move(buf);
}

DayTradeStockInfoResponse FfiConverterTypeDayTradeStockInfoResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalTypeDayTradeStockInfo::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeDayTradeStockInfoResponse::write(RustStream &stream, const DayTradeStockInfoResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalTypeDayTradeStockInfo::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeDayTradeStockInfoResponse::allocation_size(const DayTradeStockInfoResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalTypeDayTradeStockInfo::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


Equity FfiConverterTypeEquity::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeEquity::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeEquity::lower(const Equity &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeEquity::write(stream, val);

    return std::move(buf);
}

Equity FfiConverterTypeEquity::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream)
    };
}

void FfiConverterTypeEquity::write(RustStream &stream, const Equity &val) {
    FfiConverterString::write(stream, val.date);
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.account);
    FfiConverterString::write(stream, val.currency);
    FfiConverterDouble::write(stream, val.yesterday_balance);
    FfiConverterDouble::write(stream, val.today_balance);
    FfiConverterDouble::write(stream, val.initial_margin);
    FfiConverterDouble::write(stream, val.maintenance_margin);
    FfiConverterDouble::write(stream, val.clearing_margin);
    FfiConverterDouble::write(stream, val.today_equity);
    FfiConverterDouble::write(stream, val.today_deposit);
    FfiConverterDouble::write(stream, val.today_withdrawal);
    FfiConverterDouble::write(stream, val.today_trading_fee);
    FfiConverterDouble::write(stream, val.today_trading_tax);
    FfiConverterDouble::write(stream, val.receivable_premium);
    FfiConverterDouble::write(stream, val.payable_premium);
    FfiConverterDouble::write(stream, val.excess_margin);
    FfiConverterDouble::write(stream, val.available_margin);
    FfiConverterDouble::write(stream, val.disgorgement);
    FfiConverterDouble::write(stream, val.opt_pnl);
    FfiConverterDouble::write(stream, val.opt_value);
    FfiConverterDouble::write(stream, val.opt_long_value);
    FfiConverterDouble::write(stream, val.opt_short_value);
    FfiConverterDouble::write(stream, val.fut_realized_pnl);
    FfiConverterDouble::write(stream, val.fut_unrealized_pnl);
    FfiConverterDouble::write(stream, val.buy_lot);
    FfiConverterDouble::write(stream, val.sell_lot);
}

int32_t FfiConverterTypeEquity::allocation_size(const Equity &val) {
    
    return 
        FfiConverterString::allocation_size(val.date) +
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterString::allocation_size(val.currency) +
        FfiConverterDouble::allocation_size(val.yesterday_balance) +
        FfiConverterDouble::allocation_size(val.today_balance) +
        FfiConverterDouble::allocation_size(val.initial_margin) +
        FfiConverterDouble::allocation_size(val.maintenance_margin) +
        FfiConverterDouble::allocation_size(val.clearing_margin) +
        FfiConverterDouble::allocation_size(val.today_equity) +
        FfiConverterDouble::allocation_size(val.today_deposit) +
        FfiConverterDouble::allocation_size(val.today_withdrawal) +
        FfiConverterDouble::allocation_size(val.today_trading_fee) +
        FfiConverterDouble::allocation_size(val.today_trading_tax) +
        FfiConverterDouble::allocation_size(val.receivable_premium) +
        FfiConverterDouble::allocation_size(val.payable_premium) +
        FfiConverterDouble::allocation_size(val.excess_margin) +
        FfiConverterDouble::allocation_size(val.available_margin) +
        FfiConverterDouble::allocation_size(val.disgorgement) +
        FfiConverterDouble::allocation_size(val.opt_pnl) +
        FfiConverterDouble::allocation_size(val.opt_value) +
        FfiConverterDouble::allocation_size(val.opt_long_value) +
        FfiConverterDouble::allocation_size(val.opt_short_value) +
        FfiConverterDouble::allocation_size(val.fut_realized_pnl) +
        FfiConverterDouble::allocation_size(val.fut_unrealized_pnl) +
        FfiConverterDouble::allocation_size(val.buy_lot) +
        FfiConverterDouble::allocation_size(val.sell_lot);
    
}


EstimateMargin FfiConverterTypeEstimateMargin::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeEstimateMargin::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeEstimateMargin::lower(const EstimateMargin &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeEstimateMargin::write(stream, val);

    return std::move(buf);
}

EstimateMargin FfiConverterTypeEstimateMargin::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterDouble::read(stream)
    };
}

void FfiConverterTypeEstimateMargin::write(RustStream &stream, const EstimateMargin &val) {
    FfiConverterString::write(stream, val.date);
    FfiConverterString::write(stream, val.currency);
    FfiConverterDouble::write(stream, val.estimate_margin);
}

int32_t FfiConverterTypeEstimateMargin::allocation_size(const EstimateMargin &val) {
    
    return 
        FfiConverterString::allocation_size(val.date) +
        FfiConverterString::allocation_size(val.currency) +
        FfiConverterDouble::allocation_size(val.estimate_margin);
    
}


EstimateMarginResponse FfiConverterTypeEstimateMarginResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeEstimateMarginResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeEstimateMarginResponse::lower(const EstimateMarginResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeEstimateMarginResponse::write(stream, val);

    return std::move(buf);
}

EstimateMarginResponse FfiConverterTypeEstimateMarginResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalTypeEstimateMargin::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeEstimateMarginResponse::write(RustStream &stream, const EstimateMarginResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalTypeEstimateMargin::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeEstimateMarginResponse::allocation_size(const EstimateMarginResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalTypeEstimateMargin::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


FilledData FfiConverterTypeFilledData::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFilledData::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFilledData::lower(const FilledData &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFilledData::write(stream, val);

    return std::move(buf);
}

FilledData FfiConverterTypeFilledData::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeBSAction::read(stream),
        FfiConverterString::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterTypeOrderType::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeFilledData::write(RustStream &stream, const FilledData &val) {
    FfiConverterString::write(stream, val.date);
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.account);
    FfiConverterString::write(stream, val.order_no);
    FfiConverterOptionalString::write(stream, val.seq_no);
    FfiConverterString::write(stream, val.stock_no);
    FfiConverterTypeBSAction::write(stream, val.buy_sell);
    FfiConverterString::write(stream, val.filled_no);
    FfiConverterDouble::write(stream, val.filled_avg_price);
    FfiConverterInt32::write(stream, val.filled_qty);
    FfiConverterDouble::write(stream, val.filled_price);
    FfiConverterTypeOrderType::write(stream, val.order_type);
    FfiConverterString::write(stream, val.filled_time);
    FfiConverterOptionalString::write(stream, val.user_def);
}

int32_t FfiConverterTypeFilledData::allocation_size(const FilledData &val) {
    
    return 
        FfiConverterString::allocation_size(val.date) +
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterString::allocation_size(val.order_no) +
        FfiConverterOptionalString::allocation_size(val.seq_no) +
        FfiConverterString::allocation_size(val.stock_no) +
        FfiConverterTypeBSAction::allocation_size(val.buy_sell) +
        FfiConverterString::allocation_size(val.filled_no) +
        FfiConverterDouble::allocation_size(val.filled_avg_price) +
        FfiConverterInt32::allocation_size(val.filled_qty) +
        FfiConverterDouble::allocation_size(val.filled_price) +
        FfiConverterTypeOrderType::allocation_size(val.order_type) +
        FfiConverterString::allocation_size(val.filled_time) +
        FfiConverterOptionalString::allocation_size(val.user_def);
    
}


FilledResponse FfiConverterTypeFilledResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFilledResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFilledResponse::lower(const FilledResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFilledResponse::write(stream, val);

    return std::move(buf);
}

FilledResponse FfiConverterTypeFilledResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalSequenceTypeFilledData::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeFilledResponse::write(RustStream &stream, const FilledResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalSequenceTypeFilledData::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeFilledResponse::allocation_size(const FilledResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalSequenceTypeFilledData::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


FutOptConditionOrder FfiConverterTypeFutOptConditionOrder::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFutOptConditionOrder::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFutOptConditionOrder::lower(const FutOptConditionOrder &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFutOptConditionOrder::write(stream, val);

    return std::move(buf);
}

FutOptConditionOrder FfiConverterTypeFutOptConditionOrder::read(RustStream &stream) {
    return {
        FfiConverterTypeBSAction::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterTypeFutOptConditionMarketType::read(stream),
        FfiConverterTypeFutOptConditionPriceType::read(stream),
        FfiConverterTypeTimeInForce::read(stream),
        FfiConverterTypeFutOptConditionOrderType::read(stream)
    };
}

void FfiConverterTypeFutOptConditionOrder::write(RustStream &stream, const FutOptConditionOrder &val) {
    FfiConverterTypeBSAction::write(stream, val.buy_sell);
    FfiConverterString::write(stream, val.symbol);
    FfiConverterOptionalString::write(stream, val.price);
    FfiConverterOptionalInt64::write(stream, val.lot);
    FfiConverterTypeFutOptConditionMarketType::write(stream, val.market_type);
    FfiConverterTypeFutOptConditionPriceType::write(stream, val.price_type);
    FfiConverterTypeTimeInForce::write(stream, val.time_in_force);
    FfiConverterTypeFutOptConditionOrderType::write(stream, val.order_type);
}

int32_t FfiConverterTypeFutOptConditionOrder::allocation_size(const FutOptConditionOrder &val) {
    
    return 
        FfiConverterTypeBSAction::allocation_size(val.buy_sell) +
        FfiConverterString::allocation_size(val.symbol) +
        FfiConverterOptionalString::allocation_size(val.price) +
        FfiConverterOptionalInt64::allocation_size(val.lot) +
        FfiConverterTypeFutOptConditionMarketType::allocation_size(val.market_type) +
        FfiConverterTypeFutOptConditionPriceType::allocation_size(val.price_type) +
        FfiConverterTypeTimeInForce::allocation_size(val.time_in_force) +
        FfiConverterTypeFutOptConditionOrderType::allocation_size(val.order_type);
    
}


FutOptFilledData FfiConverterTypeFutOptFilledData::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFutOptFilledData::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFutOptFilledData::lower(const FutOptFilledData &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFutOptFilledData::write(stream, val);

    return std::move(buf);
}

FutOptFilledData FfiConverterTypeFutOptFilledData::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeBSAction::read(stream),
        FfiConverterString::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterTypeFutOptOrderType::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalTypeCallPut::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalTypeCallPut::read(stream),
        FfiConverterOptionalTypeBSAction::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeFutOptFilledData::write(RustStream &stream, const FutOptFilledData &val) {
    FfiConverterString::write(stream, val.date);
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.account);
    FfiConverterString::write(stream, val.order_no);
    FfiConverterOptionalString::write(stream, val.seq_no);
    FfiConverterString::write(stream, val.symbol);
    FfiConverterTypeBSAction::write(stream, val.buy_sell);
    FfiConverterString::write(stream, val.filled_no);
    FfiConverterDouble::write(stream, val.filled_avg_price);
    FfiConverterInt32::write(stream, val.filled_lot);
    FfiConverterDouble::write(stream, val.filled_price);
    FfiConverterTypeFutOptOrderType::write(stream, val.order_type);
    FfiConverterString::write(stream, val.filled_time);
    FfiConverterOptionalString::write(stream, val.expiry_date);
    FfiConverterOptionalDouble::write(stream, val.strike_price);
    FfiConverterOptionalTypeCallPut::write(stream, val.call_put);
    FfiConverterOptionalString::write(stream, val.symbol_leg2);
    FfiConverterOptionalString::write(stream, val.expiry_date_leg2);
    FfiConverterOptionalDouble::write(stream, val.strike_price_leg2);
    FfiConverterOptionalTypeCallPut::write(stream, val.call_put_leg2);
    FfiConverterOptionalTypeBSAction::write(stream, val.buy_sell_leg2);
    FfiConverterOptionalString::write(stream, val.user_def);
}

int32_t FfiConverterTypeFutOptFilledData::allocation_size(const FutOptFilledData &val) {
    
    return 
        FfiConverterString::allocation_size(val.date) +
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterString::allocation_size(val.order_no) +
        FfiConverterOptionalString::allocation_size(val.seq_no) +
        FfiConverterString::allocation_size(val.symbol) +
        FfiConverterTypeBSAction::allocation_size(val.buy_sell) +
        FfiConverterString::allocation_size(val.filled_no) +
        FfiConverterDouble::allocation_size(val.filled_avg_price) +
        FfiConverterInt32::allocation_size(val.filled_lot) +
        FfiConverterDouble::allocation_size(val.filled_price) +
        FfiConverterTypeFutOptOrderType::allocation_size(val.order_type) +
        FfiConverterString::allocation_size(val.filled_time) +
        FfiConverterOptionalString::allocation_size(val.expiry_date) +
        FfiConverterOptionalDouble::allocation_size(val.strike_price) +
        FfiConverterOptionalTypeCallPut::allocation_size(val.call_put) +
        FfiConverterOptionalString::allocation_size(val.symbol_leg2) +
        FfiConverterOptionalString::allocation_size(val.expiry_date_leg2) +
        FfiConverterOptionalDouble::allocation_size(val.strike_price_leg2) +
        FfiConverterOptionalTypeCallPut::allocation_size(val.call_put_leg2) +
        FfiConverterOptionalTypeBSAction::allocation_size(val.buy_sell_leg2) +
        FfiConverterOptionalString::allocation_size(val.user_def);
    
}


FutOptModifyLot FfiConverterTypeFutOptModifyLot::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFutOptModifyLot::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFutOptModifyLot::lower(const FutOptModifyLot &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFutOptModifyLot::write(stream, val);

    return std::move(buf);
}

FutOptModifyLot FfiConverterTypeFutOptModifyLot::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeFutOptMarketType::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterInt64::read(stream)
    };
}

void FfiConverterTypeFutOptModifyLot::write(RustStream &stream, const FutOptModifyLot &val) {
    FfiConverterString::write(stream, val.txse);
    FfiConverterString::write(stream, val.order_no);
    FfiConverterString::write(stream, val.date);
    FfiConverterTypeFutOptMarketType::write(stream, val.market_type);
    FfiConverterString::write(stream, val.asty);
    FfiConverterString::write(stream, val.symbol);
    FfiConverterInt64::write(stream, val.new_quantity);
}

int32_t FfiConverterTypeFutOptModifyLot::allocation_size(const FutOptModifyLot &val) {
    
    return 
        FfiConverterString::allocation_size(val.txse) +
        FfiConverterString::allocation_size(val.order_no) +
        FfiConverterString::allocation_size(val.date) +
        FfiConverterTypeFutOptMarketType::allocation_size(val.market_type) +
        FfiConverterString::allocation_size(val.asty) +
        FfiConverterString::allocation_size(val.symbol) +
        FfiConverterInt64::allocation_size(val.new_quantity);
    
}


FutOptModifyPrice FfiConverterTypeFutOptModifyPrice::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFutOptModifyPrice::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFutOptModifyPrice::lower(const FutOptModifyPrice &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFutOptModifyPrice::write(stream, val);

    return std::move(buf);
}

FutOptModifyPrice FfiConverterTypeFutOptModifyPrice::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeFutOptMarketType::read(stream),
        FfiConverterTypeFutOptPriceType::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalTypeFutOptPriceType::read(stream)
    };
}

void FfiConverterTypeFutOptModifyPrice::write(RustStream &stream, const FutOptModifyPrice &val) {
    FfiConverterString::write(stream, val.txse);
    FfiConverterString::write(stream, val.order_no);
    FfiConverterString::write(stream, val.date);
    FfiConverterString::write(stream, val.asty);
    FfiConverterTypeFutOptMarketType::write(stream, val.market_type);
    FfiConverterTypeFutOptPriceType::write(stream, val.price_type);
    FfiConverterString::write(stream, val.stock_no);
    FfiConverterOptionalString::write(stream, val.new_price);
    FfiConverterOptionalTypeFutOptPriceType::write(stream, val.new_price_type);
}

int32_t FfiConverterTypeFutOptModifyPrice::allocation_size(const FutOptModifyPrice &val) {
    
    return 
        FfiConverterString::allocation_size(val.txse) +
        FfiConverterString::allocation_size(val.order_no) +
        FfiConverterString::allocation_size(val.date) +
        FfiConverterString::allocation_size(val.asty) +
        FfiConverterTypeFutOptMarketType::allocation_size(val.market_type) +
        FfiConverterTypeFutOptPriceType::allocation_size(val.price_type) +
        FfiConverterString::allocation_size(val.stock_no) +
        FfiConverterOptionalString::allocation_size(val.new_price) +
        FfiConverterOptionalTypeFutOptPriceType::allocation_size(val.new_price_type);
    
}


FutOptOrder FfiConverterTypeFutOptOrder::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFutOptOrder::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFutOptOrder::lower(const FutOptOrder &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFutOptOrder::write(stream, val);

    return std::move(buf);
}

FutOptOrder FfiConverterTypeFutOptOrder::read(RustStream &stream) {
    return {
        FfiConverterTypeBSAction::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalTypeBSAction::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterInt64::read(stream),
        FfiConverterTypeFutOptMarketType::read(stream),
        FfiConverterTypeFutOptPriceType::read(stream),
        FfiConverterTypeTimeInForce::read(stream),
        FfiConverterTypeFutOptOrderType::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeFutOptOrder::write(RustStream &stream, const FutOptOrder &val) {
    FfiConverterTypeBSAction::write(stream, val.buy_sell);
    FfiConverterString::write(stream, val.symbol);
    FfiConverterOptionalTypeBSAction::write(stream, val.buy_sell2);
    FfiConverterOptionalString::write(stream, val.symbol2);
    FfiConverterOptionalString::write(stream, val.price);
    FfiConverterInt64::write(stream, val.lot);
    FfiConverterTypeFutOptMarketType::write(stream, val.market_type);
    FfiConverterTypeFutOptPriceType::write(stream, val.price_type);
    FfiConverterTypeTimeInForce::write(stream, val.time_in_force);
    FfiConverterTypeFutOptOrderType::write(stream, val.order_type);
    FfiConverterOptionalString::write(stream, val.user_def);
}

int32_t FfiConverterTypeFutOptOrder::allocation_size(const FutOptOrder &val) {
    
    return 
        FfiConverterTypeBSAction::allocation_size(val.buy_sell) +
        FfiConverterString::allocation_size(val.symbol) +
        FfiConverterOptionalTypeBSAction::allocation_size(val.buy_sell2) +
        FfiConverterOptionalString::allocation_size(val.symbol2) +
        FfiConverterOptionalString::allocation_size(val.price) +
        FfiConverterInt64::allocation_size(val.lot) +
        FfiConverterTypeFutOptMarketType::allocation_size(val.market_type) +
        FfiConverterTypeFutOptPriceType::allocation_size(val.price_type) +
        FfiConverterTypeTimeInForce::allocation_size(val.time_in_force) +
        FfiConverterTypeFutOptOrderType::allocation_size(val.order_type) +
        FfiConverterOptionalString::allocation_size(val.user_def);
    
}


FutOptOrderDetail FfiConverterTypeFutOptOrderDetail::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFutOptOrderDetail::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFutOptOrderDetail::lower(const FutOptOrderDetail &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFutOptOrderDetail::write(stream, val);

    return std::move(buf);
}

FutOptOrderDetail FfiConverterTypeFutOptOrderDetail::read(RustStream &stream) {
    return {
        FfiConverterOptionalInt32::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalInt32::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeFutOptOrderDetail::write(RustStream &stream, const FutOptOrderDetail &val) {
    FfiConverterOptionalInt32::write(stream, val.function_type);
    FfiConverterString::write(stream, val.modified_time);
    FfiConverterOptionalInt64::write(stream, val.before_lot);
    FfiConverterOptionalInt64::write(stream, val.after_lot);
    FfiConverterOptionalDouble::write(stream, val.before_price);
    FfiConverterOptionalDouble::write(stream, val.after_price);
    FfiConverterOptionalDouble::write(stream, val.filled_money);
    FfiConverterOptionalString::write(stream, val.error_message);
    FfiConverterOptionalInt32::write(stream, val.status);
    FfiConverterOptionalString::write(stream, val.err_msg);
}

int32_t FfiConverterTypeFutOptOrderDetail::allocation_size(const FutOptOrderDetail &val) {
    
    return 
        FfiConverterOptionalInt32::allocation_size(val.function_type) +
        FfiConverterString::allocation_size(val.modified_time) +
        FfiConverterOptionalInt64::allocation_size(val.before_lot) +
        FfiConverterOptionalInt64::allocation_size(val.after_lot) +
        FfiConverterOptionalDouble::allocation_size(val.before_price) +
        FfiConverterOptionalDouble::allocation_size(val.after_price) +
        FfiConverterOptionalDouble::allocation_size(val.filled_money) +
        FfiConverterOptionalString::allocation_size(val.error_message) +
        FfiConverterOptionalInt32::allocation_size(val.status) +
        FfiConverterOptionalString::allocation_size(val.err_msg);
    
}


FutOptOrderResponse FfiConverterTypeFutOptOrderResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFutOptOrderResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFutOptOrderResponse::lower(const FutOptOrderResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFutOptOrderResponse::write(stream, val);

    return std::move(buf);
}

FutOptOrderResponse FfiConverterTypeFutOptOrderResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalTypeFutOptOrderResult::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeFutOptOrderResponse::write(RustStream &stream, const FutOptOrderResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalTypeFutOptOrderResult::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeFutOptOrderResponse::allocation_size(const FutOptOrderResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalTypeFutOptOrderResult::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


FutOptOrderResult FfiConverterTypeFutOptOrderResult::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFutOptOrderResult::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFutOptOrderResult::lower(const FutOptOrderResult &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFutOptOrderResult::write(stream, val);

    return std::move(buf);
}

FutOptOrderResult FfiConverterTypeFutOptOrderResult::read(RustStream &stream) {
    return {
        FfiConverterOptionalInt32::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalInt32::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterTypeFutOptMarketType::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalInt32::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalTypeCallPut::read(stream),
        FfiConverterOptionalTypeBSAction::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalTypeCallPut::read(stream),
        FfiConverterOptionalTypeBSAction::read(stream),
        FfiConverterOptionalTypeFutOptPriceType::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt32::read(stream),
        FfiConverterOptionalTypeTimeInForce::read(stream),
        FfiConverterOptionalTypeFutOptOrderType::read(stream),
        FfiConverterOptionalInt32::read(stream),
        FfiConverterBool::read(stream),
        FfiConverterOptionalTypeFutOptPriceType::read(stream),
        FfiConverterOptionalInt32::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalInt32::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalSequenceTypeFutOptOrderDetail::read(stream)
    };
}

void FfiConverterTypeFutOptOrderResult::write(RustStream &stream, const FutOptOrderResult &val) {
    FfiConverterOptionalInt32::write(stream, val.function_type);
    FfiConverterString::write(stream, val.date);
    FfiConverterString::write(stream, val.seq_no);
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.account);
    FfiConverterOptionalString::write(stream, val.order_no);
    FfiConverterOptionalInt32::write(stream, val.asset_type);
    FfiConverterOptionalString::write(stream, val.market);
    FfiConverterTypeFutOptMarketType::write(stream, val.market_type);
    FfiConverterOptionalString::write(stream, val.symbol);
    FfiConverterOptionalInt32::write(stream, val.unit);
    FfiConverterOptionalString::write(stream, val.currency);
    FfiConverterOptionalString::write(stream, val.expiry_date);
    FfiConverterOptionalDouble::write(stream, val.strike_price);
    FfiConverterOptionalTypeCallPut::write(stream, val.call_put);
    FfiConverterOptionalTypeBSAction::write(stream, val.buy_sell);
    FfiConverterOptionalString::write(stream, val.symbol_leg2);
    FfiConverterOptionalString::write(stream, val.expiry_date_leg2);
    FfiConverterOptionalDouble::write(stream, val.strike_price_leg2);
    FfiConverterOptionalTypeCallPut::write(stream, val.call_put_leg2);
    FfiConverterOptionalTypeBSAction::write(stream, val.buy_sell_leg2);
    FfiConverterOptionalTypeFutOptPriceType::write(stream, val.price_type);
    FfiConverterOptionalDouble::write(stream, val.price);
    FfiConverterOptionalDouble::write(stream, val.after_price);
    FfiConverterOptionalInt64::write(stream, val.lot);
    FfiConverterOptionalInt32::write(stream, val.after_lot);
    FfiConverterOptionalTypeTimeInForce::write(stream, val.time_in_force);
    FfiConverterOptionalTypeFutOptOrderType::write(stream, val.order_type);
    FfiConverterOptionalInt32::write(stream, val.status);
    FfiConverterBool::write(stream, val.is_pre_order);
    FfiConverterOptionalTypeFutOptPriceType::write(stream, val.after_price_type);
    FfiConverterOptionalInt32::write(stream, val.filled_lot);
    FfiConverterOptionalDouble::write(stream, val.filled_money);
    FfiConverterOptionalInt32::write(stream, val.before_lot);
    FfiConverterOptionalDouble::write(stream, val.before_price);
    FfiConverterOptionalString::write(stream, val.user_def);
    FfiConverterString::write(stream, val.last_time);
    FfiConverterOptionalString::write(stream, val.error_message);
    FfiConverterOptionalSequenceTypeFutOptOrderDetail::write(stream, val.details);
}

int32_t FfiConverterTypeFutOptOrderResult::allocation_size(const FutOptOrderResult &val) {
    
    return 
        FfiConverterOptionalInt32::allocation_size(val.function_type) +
        FfiConverterString::allocation_size(val.date) +
        FfiConverterString::allocation_size(val.seq_no) +
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterOptionalString::allocation_size(val.order_no) +
        FfiConverterOptionalInt32::allocation_size(val.asset_type) +
        FfiConverterOptionalString::allocation_size(val.market) +
        FfiConverterTypeFutOptMarketType::allocation_size(val.market_type) +
        FfiConverterOptionalString::allocation_size(val.symbol) +
        FfiConverterOptionalInt32::allocation_size(val.unit) +
        FfiConverterOptionalString::allocation_size(val.currency) +
        FfiConverterOptionalString::allocation_size(val.expiry_date) +
        FfiConverterOptionalDouble::allocation_size(val.strike_price) +
        FfiConverterOptionalTypeCallPut::allocation_size(val.call_put) +
        FfiConverterOptionalTypeBSAction::allocation_size(val.buy_sell) +
        FfiConverterOptionalString::allocation_size(val.symbol_leg2) +
        FfiConverterOptionalString::allocation_size(val.expiry_date_leg2) +
        FfiConverterOptionalDouble::allocation_size(val.strike_price_leg2) +
        FfiConverterOptionalTypeCallPut::allocation_size(val.call_put_leg2) +
        FfiConverterOptionalTypeBSAction::allocation_size(val.buy_sell_leg2) +
        FfiConverterOptionalTypeFutOptPriceType::allocation_size(val.price_type) +
        FfiConverterOptionalDouble::allocation_size(val.price) +
        FfiConverterOptionalDouble::allocation_size(val.after_price) +
        FfiConverterOptionalInt64::allocation_size(val.lot) +
        FfiConverterOptionalInt32::allocation_size(val.after_lot) +
        FfiConverterOptionalTypeTimeInForce::allocation_size(val.time_in_force) +
        FfiConverterOptionalTypeFutOptOrderType::allocation_size(val.order_type) +
        FfiConverterOptionalInt32::allocation_size(val.status) +
        FfiConverterBool::allocation_size(val.is_pre_order) +
        FfiConverterOptionalTypeFutOptPriceType::allocation_size(val.after_price_type) +
        FfiConverterOptionalInt32::allocation_size(val.filled_lot) +
        FfiConverterOptionalDouble::allocation_size(val.filled_money) +
        FfiConverterOptionalInt32::allocation_size(val.before_lot) +
        FfiConverterOptionalDouble::allocation_size(val.before_price) +
        FfiConverterOptionalString::allocation_size(val.user_def) +
        FfiConverterString::allocation_size(val.last_time) +
        FfiConverterOptionalString::allocation_size(val.error_message) +
        FfiConverterOptionalSequenceTypeFutOptOrderDetail::allocation_size(val.details);
    
}


FutOptTpslOrder FfiConverterTypeFutOptTPSLOrder::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFutOptTPSLOrder::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFutOptTPSLOrder::lower(const FutOptTpslOrder &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFutOptTPSLOrder::write(stream, val);

    return std::move(buf);
}

FutOptTpslOrder FfiConverterTypeFutOptTPSLOrder::read(RustStream &stream) {
    return {
        FfiConverterTypeTimeInForce::read(stream),
        FfiConverterTypeFutOptConditionPriceType::read(stream),
        FfiConverterTypeFutOptConditionOrderType::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalTypeTriggerContent::read(stream)
    };
}

void FfiConverterTypeFutOptTPSLOrder::write(RustStream &stream, const FutOptTpslOrder &val) {
    FfiConverterTypeTimeInForce::write(stream, val.time_in_force);
    FfiConverterTypeFutOptConditionPriceType::write(stream, val.price_type);
    FfiConverterTypeFutOptConditionOrderType::write(stream, val.order_type);
    FfiConverterString::write(stream, val.target_price);
    FfiConverterOptionalString::write(stream, val.price);
    FfiConverterOptionalTypeTriggerContent::write(stream, val.trigger);
}

int32_t FfiConverterTypeFutOptTPSLOrder::allocation_size(const FutOptTpslOrder &val) {
    
    return 
        FfiConverterTypeTimeInForce::allocation_size(val.time_in_force) +
        FfiConverterTypeFutOptConditionPriceType::allocation_size(val.price_type) +
        FfiConverterTypeFutOptConditionOrderType::allocation_size(val.order_type) +
        FfiConverterString::allocation_size(val.target_price) +
        FfiConverterOptionalString::allocation_size(val.price) +
        FfiConverterOptionalTypeTriggerContent::allocation_size(val.trigger);
    
}


FutOptTPSLWrapper FfiConverterTypeFutOptTPSLWrapper::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFutOptTPSLWrapper::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFutOptTPSLWrapper::lower(const FutOptTPSLWrapper &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFutOptTPSLWrapper::write(stream, val);

    return std::move(buf);
}

FutOptTPSLWrapper FfiConverterTypeFutOptTPSLWrapper::read(RustStream &stream) {
    return {
        FfiConverterTypeStopSign::read(stream),
        FfiConverterOptionalTypeFutOptTPSLOrder::read(stream),
        FfiConverterOptionalTypeFutOptTPSLOrder::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalBool::read(stream)
    };
}

void FfiConverterTypeFutOptTPSLWrapper::write(RustStream &stream, const FutOptTPSLWrapper &val) {
    FfiConverterTypeStopSign::write(stream, val.stop_sign);
    FfiConverterOptionalTypeFutOptTPSLOrder::write(stream, val.tp);
    FfiConverterOptionalTypeFutOptTPSLOrder::write(stream, val.sl);
    FfiConverterOptionalString::write(stream, val.end_date);
    FfiConverterOptionalBool::write(stream, val.intraday);
}

int32_t FfiConverterTypeFutOptTPSLWrapper::allocation_size(const FutOptTPSLWrapper &val) {
    
    return 
        FfiConverterTypeStopSign::allocation_size(val.stop_sign) +
        FfiConverterOptionalTypeFutOptTPSLOrder::allocation_size(val.tp) +
        FfiConverterOptionalTypeFutOptTPSLOrder::allocation_size(val.sl) +
        FfiConverterOptionalString::allocation_size(val.end_date) +
        FfiConverterOptionalBool::allocation_size(val.intraday);
    
}


FutOptTrailOrder FfiConverterTypeFutOptTrailOrder::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFutOptTrailOrder::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFutOptTrailOrder::lower(const FutOptTrailOrder &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFutOptTrailOrder::write(stream, val);

    return std::move(buf);
}

FutOptTrailOrder FfiConverterTypeFutOptTrailOrder::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeDirection::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterTypeBSAction::read(stream),
        FfiConverterInt64::read(stream),
        FfiConverterTypeFutOptConditionPriceType::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterTypeTimeInForce::read(stream),
        FfiConverterTypeFutOptConditionOrderType::read(stream)
    };
}

void FfiConverterTypeFutOptTrailOrder::write(RustStream &stream, const FutOptTrailOrder &val) {
    FfiConverterString::write(stream, val.symbol);
    FfiConverterString::write(stream, val.price);
    FfiConverterTypeDirection::write(stream, val.direction);
    FfiConverterInt32::write(stream, val.tick_num);
    FfiConverterTypeBSAction::write(stream, val.buy_sell);
    FfiConverterInt64::write(stream, val.lot);
    FfiConverterTypeFutOptConditionPriceType::write(stream, val.price_type);
    FfiConverterInt32::write(stream, val.diff);
    FfiConverterTypeTimeInForce::write(stream, val.time_in_force);
    FfiConverterTypeFutOptConditionOrderType::write(stream, val.order_type);
}

int32_t FfiConverterTypeFutOptTrailOrder::allocation_size(const FutOptTrailOrder &val) {
    
    return 
        FfiConverterString::allocation_size(val.symbol) +
        FfiConverterString::allocation_size(val.price) +
        FfiConverterTypeDirection::allocation_size(val.direction) +
        FfiConverterInt32::allocation_size(val.tick_num) +
        FfiConverterTypeBSAction::allocation_size(val.buy_sell) +
        FfiConverterInt64::allocation_size(val.lot) +
        FfiConverterTypeFutOptConditionPriceType::allocation_size(val.price_type) +
        FfiConverterInt32::allocation_size(val.diff) +
        FfiConverterTypeTimeInForce::allocation_size(val.time_in_force) +
        FfiConverterTypeFutOptConditionOrderType::allocation_size(val.order_type);
    
}


HybridPosition FfiConverterTypeHybridPosition::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeHybridPosition::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeHybridPosition::lower(const HybridPosition &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeHybridPosition::write(stream, val);

    return std::move(buf);
}

HybridPosition FfiConverterTypeHybridPosition::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterBool::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalTypeCallPut::read(stream),
        FfiConverterTypeBSAction::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterInt64::read(stream),
        FfiConverterInt64::read(stream),
        FfiConverterOptionalTypeFutOptOrderType::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterOptionalSequenceTypeSpreadPosition::read(stream)
    };
}

void FfiConverterTypeHybridPosition::write(RustStream &stream, const HybridPosition &val) {
    FfiConverterString::write(stream, val.date);
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.account);
    FfiConverterBool::write(stream, val.is_spread);
    FfiConverterInt32::write(stream, val.position_kind);
    FfiConverterString::write(stream, val.symbol);
    FfiConverterString::write(stream, val.expiry_date);
    FfiConverterOptionalDouble::write(stream, val.strike_price);
    FfiConverterOptionalTypeCallPut::write(stream, val.call_put);
    FfiConverterTypeBSAction::write(stream, val.buy_sell);
    FfiConverterOptionalDouble::write(stream, val.price);
    FfiConverterInt64::write(stream, val.orig_lots);
    FfiConverterInt64::write(stream, val.tradable_lot);
    FfiConverterOptionalTypeFutOptOrderType::write(stream, val.order_type);
    FfiConverterOptionalString::write(stream, val.currency);
    FfiConverterString::write(stream, val.market_price);
    FfiConverterDouble::write(stream, val.initial_margin);
    FfiConverterDouble::write(stream, val.maintenance_margin);
    FfiConverterDouble::write(stream, val.clearing_margin);
    FfiConverterDouble::write(stream, val.initial_margin_all_single);
    FfiConverterDouble::write(stream, val.opt_value);
    FfiConverterDouble::write(stream, val.opt_long_value);
    FfiConverterDouble::write(stream, val.opt_short_value);
    FfiConverterDouble::write(stream, val.profit_or_loss);
    FfiConverterDouble::write(stream, val.premium);
    FfiConverterOptionalSequenceTypeSpreadPosition::write(stream, val.spreads);
}

int32_t FfiConverterTypeHybridPosition::allocation_size(const HybridPosition &val) {
    
    return 
        FfiConverterString::allocation_size(val.date) +
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterBool::allocation_size(val.is_spread) +
        FfiConverterInt32::allocation_size(val.position_kind) +
        FfiConverterString::allocation_size(val.symbol) +
        FfiConverterString::allocation_size(val.expiry_date) +
        FfiConverterOptionalDouble::allocation_size(val.strike_price) +
        FfiConverterOptionalTypeCallPut::allocation_size(val.call_put) +
        FfiConverterTypeBSAction::allocation_size(val.buy_sell) +
        FfiConverterOptionalDouble::allocation_size(val.price) +
        FfiConverterInt64::allocation_size(val.orig_lots) +
        FfiConverterInt64::allocation_size(val.tradable_lot) +
        FfiConverterOptionalTypeFutOptOrderType::allocation_size(val.order_type) +
        FfiConverterOptionalString::allocation_size(val.currency) +
        FfiConverterString::allocation_size(val.market_price) +
        FfiConverterDouble::allocation_size(val.initial_margin) +
        FfiConverterDouble::allocation_size(val.maintenance_margin) +
        FfiConverterDouble::allocation_size(val.clearing_margin) +
        FfiConverterDouble::allocation_size(val.initial_margin_all_single) +
        FfiConverterDouble::allocation_size(val.opt_value) +
        FfiConverterDouble::allocation_size(val.opt_long_value) +
        FfiConverterDouble::allocation_size(val.opt_short_value) +
        FfiConverterDouble::allocation_size(val.profit_or_loss) +
        FfiConverterDouble::allocation_size(val.premium) +
        FfiConverterOptionalSequenceTypeSpreadPosition::allocation_size(val.spreads);
    
}


Inventory FfiConverterTypeInventory::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeInventory::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeInventory::lower(const Inventory &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeInventory::write(stream, val);

    return std::move(buf);
}

Inventory FfiConverterTypeInventory::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeOrderType::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterTypeInventoryOdd::read(stream)
    };
}

void FfiConverterTypeInventory::write(RustStream &stream, const Inventory &val) {
    FfiConverterString::write(stream, val.date);
    FfiConverterString::write(stream, val.account);
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.stock_no);
    FfiConverterTypeOrderType::write(stream, val.order_type);
    FfiConverterInt32::write(stream, val.lastday_qty);
    FfiConverterInt32::write(stream, val.buy_qty);
    FfiConverterInt32::write(stream, val.buy_filled_qty);
    FfiConverterInt32::write(stream, val.buy_value);
    FfiConverterInt32::write(stream, val.today_qty);
    FfiConverterInt32::write(stream, val.tradable_qty);
    FfiConverterInt32::write(stream, val.sell_qty);
    FfiConverterInt32::write(stream, val.sell_filled_qty);
    FfiConverterInt32::write(stream, val.sell_value);
    FfiConverterTypeInventoryOdd::write(stream, val.odd);
}

int32_t FfiConverterTypeInventory::allocation_size(const Inventory &val) {
    
    return 
        FfiConverterString::allocation_size(val.date) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.stock_no) +
        FfiConverterTypeOrderType::allocation_size(val.order_type) +
        FfiConverterInt32::allocation_size(val.lastday_qty) +
        FfiConverterInt32::allocation_size(val.buy_qty) +
        FfiConverterInt32::allocation_size(val.buy_filled_qty) +
        FfiConverterInt32::allocation_size(val.buy_value) +
        FfiConverterInt32::allocation_size(val.today_qty) +
        FfiConverterInt32::allocation_size(val.tradable_qty) +
        FfiConverterInt32::allocation_size(val.sell_qty) +
        FfiConverterInt32::allocation_size(val.sell_filled_qty) +
        FfiConverterInt32::allocation_size(val.sell_value) +
        FfiConverterTypeInventoryOdd::allocation_size(val.odd);
    
}


InventoryOdd FfiConverterTypeInventoryOdd::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeInventoryOdd::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeInventoryOdd::lower(const InventoryOdd &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeInventoryOdd::write(stream, val);

    return std::move(buf);
}

InventoryOdd FfiConverterTypeInventoryOdd::read(RustStream &stream) {
    return {
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream)
    };
}

void FfiConverterTypeInventoryOdd::write(RustStream &stream, const InventoryOdd &val) {
    FfiConverterInt32::write(stream, val.lastday_qty);
    FfiConverterInt32::write(stream, val.buy_qty);
    FfiConverterInt32::write(stream, val.buy_filled_qty);
    FfiConverterInt32::write(stream, val.buy_value);
    FfiConverterInt32::write(stream, val.today_qty);
    FfiConverterInt32::write(stream, val.tradable_qty);
    FfiConverterInt32::write(stream, val.sell_qty);
    FfiConverterInt32::write(stream, val.sell_filled_qty);
    FfiConverterInt32::write(stream, val.sell_value);
}

int32_t FfiConverterTypeInventoryOdd::allocation_size(const InventoryOdd &val) {
    
    return 
        FfiConverterInt32::allocation_size(val.lastday_qty) +
        FfiConverterInt32::allocation_size(val.buy_qty) +
        FfiConverterInt32::allocation_size(val.buy_filled_qty) +
        FfiConverterInt32::allocation_size(val.buy_value) +
        FfiConverterInt32::allocation_size(val.today_qty) +
        FfiConverterInt32::allocation_size(val.tradable_qty) +
        FfiConverterInt32::allocation_size(val.sell_qty) +
        FfiConverterInt32::allocation_size(val.sell_filled_qty) +
        FfiConverterInt32::allocation_size(val.sell_value);
    
}


InventoryResponse FfiConverterTypeInventoryResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeInventoryResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeInventoryResponse::lower(const InventoryResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeInventoryResponse::write(stream, val);

    return std::move(buf);
}

InventoryResponse FfiConverterTypeInventoryResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalSequenceTypeInventory::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeInventoryResponse::write(RustStream &stream, const InventoryResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalSequenceTypeInventory::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeInventoryResponse::allocation_size(const InventoryResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalSequenceTypeInventory::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


LoginResponse FfiConverterTypeLoginResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeLoginResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeLoginResponse::lower(const LoginResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeLoginResponse::write(stream, val);

    return std::move(buf);
}

LoginResponse FfiConverterTypeLoginResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalSequenceTypeAccount::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeLoginResponse::write(RustStream &stream, const LoginResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalSequenceTypeAccount::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeLoginResponse::allocation_size(const LoginResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalSequenceTypeAccount::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


MaintenanceData FfiConverterTypeMaintenanceData::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeMaintenanceData::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeMaintenanceData::lower(const MaintenanceData &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeMaintenanceData::write(stream, val);

    return std::move(buf);
}

MaintenanceData FfiConverterTypeMaintenanceData::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeMaintenanceSummary::read(stream),
        FfiConverterSequenceTypeMaintenanceDetail::read(stream)
    };
}

void FfiConverterTypeMaintenanceData::write(RustStream &stream, const MaintenanceData &val) {
    FfiConverterString::write(stream, val.date);
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.account);
    FfiConverterTypeMaintenanceSummary::write(stream, val.maintenance_summary);
    FfiConverterSequenceTypeMaintenanceDetail::write(stream, val.maintenance_detail);
}

int32_t FfiConverterTypeMaintenanceData::allocation_size(const MaintenanceData &val) {
    
    return 
        FfiConverterString::allocation_size(val.date) +
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterTypeMaintenanceSummary::allocation_size(val.maintenance_summary) +
        FfiConverterSequenceTypeMaintenanceDetail::allocation_size(val.maintenance_detail);
    
}


MaintenanceDetail FfiConverterTypeMaintenanceDetail::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeMaintenanceDetail::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeMaintenanceDetail::lower(const MaintenanceDetail &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeMaintenanceDetail::write(stream, val);

    return std::move(buf);
}

MaintenanceDetail FfiConverterTypeMaintenanceDetail::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalTypeOrderType::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalDouble::read(stream)
    };
}

void FfiConverterTypeMaintenanceDetail::write(RustStream &stream, const MaintenanceDetail &val) {
    FfiConverterString::write(stream, val.stock_no);
    FfiConverterString::write(stream, val.order_no);
    FfiConverterOptionalTypeOrderType::write(stream, val.order_type);
    FfiConverterOptionalInt64::write(stream, val.quantity);
    FfiConverterOptionalDouble::write(stream, val.price);
    FfiConverterOptionalDouble::write(stream, val.cost_price);
    FfiConverterOptionalInt64::write(stream, val.shortsell_margin);
    FfiConverterOptionalDouble::write(stream, val.collateral);
    FfiConverterOptionalInt64::write(stream, val.margin_loan_amt);
    FfiConverterOptionalDouble::write(stream, val.maintenance_ratio);
    FfiConverterOptionalDouble::write(stream, val.collateral_interest);
    FfiConverterOptionalDouble::write(stream, val.margin_interest);
    FfiConverterOptionalDouble::write(stream, val.shortsell_interest);
}

int32_t FfiConverterTypeMaintenanceDetail::allocation_size(const MaintenanceDetail &val) {
    
    return 
        FfiConverterString::allocation_size(val.stock_no) +
        FfiConverterString::allocation_size(val.order_no) +
        FfiConverterOptionalTypeOrderType::allocation_size(val.order_type) +
        FfiConverterOptionalInt64::allocation_size(val.quantity) +
        FfiConverterOptionalDouble::allocation_size(val.price) +
        FfiConverterOptionalDouble::allocation_size(val.cost_price) +
        FfiConverterOptionalInt64::allocation_size(val.shortsell_margin) +
        FfiConverterOptionalDouble::allocation_size(val.collateral) +
        FfiConverterOptionalInt64::allocation_size(val.margin_loan_amt) +
        FfiConverterOptionalDouble::allocation_size(val.maintenance_ratio) +
        FfiConverterOptionalDouble::allocation_size(val.collateral_interest) +
        FfiConverterOptionalDouble::allocation_size(val.margin_interest) +
        FfiConverterOptionalDouble::allocation_size(val.shortsell_interest);
    
}


MaintenanceResponse FfiConverterTypeMaintenanceResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeMaintenanceResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeMaintenanceResponse::lower(const MaintenanceResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeMaintenanceResponse::write(stream, val);

    return std::move(buf);
}

MaintenanceResponse FfiConverterTypeMaintenanceResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalTypeMaintenanceData::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeMaintenanceResponse::write(RustStream &stream, const MaintenanceResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalTypeMaintenanceData::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeMaintenanceResponse::allocation_size(const MaintenanceResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalTypeMaintenanceData::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


MaintenanceSummary FfiConverterTypeMaintenanceSummary::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeMaintenanceSummary::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeMaintenanceSummary::lower(const MaintenanceSummary &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeMaintenanceSummary::write(stream, val);

    return std::move(buf);
}

MaintenanceSummary FfiConverterTypeMaintenanceSummary::read(RustStream &stream) {
    return {
        FfiConverterInt64::read(stream),
        FfiConverterInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterInt64::read(stream),
        FfiConverterDouble::read(stream)
    };
}

void FfiConverterTypeMaintenanceSummary::write(RustStream &stream, const MaintenanceSummary &val) {
    FfiConverterInt64::write(stream, val.margin_value);
    FfiConverterInt64::write(stream, val.shortsell_value);
    FfiConverterOptionalInt64::write(stream, val.shortsell_margin);
    FfiConverterOptionalInt64::write(stream, val.collateral);
    FfiConverterInt64::write(stream, val.margin_loan_amt);
    FfiConverterDouble::write(stream, val.maintenance_ratio);
}

int32_t FfiConverterTypeMaintenanceSummary::allocation_size(const MaintenanceSummary &val) {
    
    return 
        FfiConverterInt64::allocation_size(val.margin_value) +
        FfiConverterInt64::allocation_size(val.shortsell_value) +
        FfiConverterOptionalInt64::allocation_size(val.shortsell_margin) +
        FfiConverterOptionalInt64::allocation_size(val.collateral) +
        FfiConverterInt64::allocation_size(val.margin_loan_amt) +
        FfiConverterDouble::allocation_size(val.maintenance_ratio);
    
}


MarginShortQuota FfiConverterTypeMarginShortQuota::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeMarginShortQuota::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeMarginShortQuota::lower(const MarginShortQuota &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeMarginShortQuota::write(stream, val);

    return std::move(buf);
}

MarginShortQuota FfiConverterTypeMarginShortQuota::read(RustStream &stream) {
    return {
        FfiConverterOptionalString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt32::read(stream),
        FfiConverterOptionalInt32::read(stream)
    };
}

void FfiConverterTypeMarginShortQuota::write(RustStream &stream, const MarginShortQuota &val) {
    FfiConverterOptionalString::write(stream, val.stock_no);
    FfiConverterString::write(stream, val.date);
    FfiConverterOptionalInt64::write(stream, val.shortsell_orig_quota);
    FfiConverterOptionalInt64::write(stream, val.shortsell_tradable_quota);
    FfiConverterOptionalInt64::write(stream, val.margin_orig_quota);
    FfiConverterOptionalInt64::write(stream, val.margin_tradable_quota);
    FfiConverterOptionalInt32::write(stream, val.margin_ratio);
    FfiConverterOptionalInt32::write(stream, val.short_ratio);
}

int32_t FfiConverterTypeMarginShortQuota::allocation_size(const MarginShortQuota &val) {
    
    return 
        FfiConverterOptionalString::allocation_size(val.stock_no) +
        FfiConverterString::allocation_size(val.date) +
        FfiConverterOptionalInt64::allocation_size(val.shortsell_orig_quota) +
        FfiConverterOptionalInt64::allocation_size(val.shortsell_tradable_quota) +
        FfiConverterOptionalInt64::allocation_size(val.margin_orig_quota) +
        FfiConverterOptionalInt64::allocation_size(val.margin_tradable_quota) +
        FfiConverterOptionalInt32::allocation_size(val.margin_ratio) +
        FfiConverterOptionalInt32::allocation_size(val.short_ratio);
    
}


MarginShortQuotaResponse FfiConverterTypeMarginShortQuotaResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeMarginShortQuotaResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeMarginShortQuotaResponse::lower(const MarginShortQuotaResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeMarginShortQuotaResponse::write(stream, val);

    return std::move(buf);
}

MarginShortQuotaResponse FfiConverterTypeMarginShortQuotaResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalTypeMarginShortQuota::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeMarginShortQuotaResponse::write(RustStream &stream, const MarginShortQuotaResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalTypeMarginShortQuota::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeMarginShortQuotaResponse::allocation_size(const MarginShortQuotaResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalTypeMarginShortQuota::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


ModifyPrice FfiConverterTypeModifyPrice::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeModifyPrice::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeModifyPrice::lower(const ModifyPrice &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeModifyPrice::write(stream, val);

    return std::move(buf);
}

ModifyPrice FfiConverterTypeModifyPrice::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypePriceType::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalTypePriceType::read(stream)
    };
}

void FfiConverterTypeModifyPrice::write(RustStream &stream, const ModifyPrice &val) {
    FfiConverterString::write(stream, val.txse);
    FfiConverterString::write(stream, val.order_no);
    FfiConverterString::write(stream, val.date);
    FfiConverterString::write(stream, val.asty);
    FfiConverterTypePriceType::write(stream, val.price_type);
    FfiConverterString::write(stream, val.stock_no);
    FfiConverterOptionalString::write(stream, val.new_price);
    FfiConverterOptionalTypePriceType::write(stream, val.new_price_type);
}

int32_t FfiConverterTypeModifyPrice::allocation_size(const ModifyPrice &val) {
    
    return 
        FfiConverterString::allocation_size(val.txse) +
        FfiConverterString::allocation_size(val.order_no) +
        FfiConverterString::allocation_size(val.date) +
        FfiConverterString::allocation_size(val.asty) +
        FfiConverterTypePriceType::allocation_size(val.price_type) +
        FfiConverterString::allocation_size(val.stock_no) +
        FfiConverterOptionalString::allocation_size(val.new_price) +
        FfiConverterOptionalTypePriceType::allocation_size(val.new_price_type);
    
}


ModifyQuantity FfiConverterTypeModifyQuantity::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeModifyQuantity::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeModifyQuantity::lower(const ModifyQuantity &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeModifyQuantity::write(stream, val);

    return std::move(buf);
}

ModifyQuantity FfiConverterTypeModifyQuantity::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeMarketType::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterInt64::read(stream)
    };
}

void FfiConverterTypeModifyQuantity::write(RustStream &stream, const ModifyQuantity &val) {
    FfiConverterString::write(stream, val.txse);
    FfiConverterString::write(stream, val.order_no);
    FfiConverterString::write(stream, val.date);
    FfiConverterTypeMarketType::write(stream, val.market_type);
    FfiConverterString::write(stream, val.asty);
    FfiConverterString::write(stream, val.stock_no);
    FfiConverterInt64::write(stream, val.new_quantity);
}

int32_t FfiConverterTypeModifyQuantity::allocation_size(const ModifyQuantity &val) {
    
    return 
        FfiConverterString::allocation_size(val.txse) +
        FfiConverterString::allocation_size(val.order_no) +
        FfiConverterString::allocation_size(val.date) +
        FfiConverterTypeMarketType::allocation_size(val.market_type) +
        FfiConverterString::allocation_size(val.asty) +
        FfiConverterString::allocation_size(val.stock_no) +
        FfiConverterInt64::allocation_size(val.new_quantity);
    
}


Order FfiConverterTypeOrder::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeOrder::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeOrder::lower(const Order &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeOrder::write(stream, val);

    return std::move(buf);
}

Order FfiConverterTypeOrder::read(RustStream &stream) {
    return {
        FfiConverterTypeBSAction::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterInt64::read(stream),
        FfiConverterTypeMarketType::read(stream),
        FfiConverterTypePriceType::read(stream),
        FfiConverterTypeTimeInForce::read(stream),
        FfiConverterTypeOrderType::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeOrder::write(RustStream &stream, const Order &val) {
    FfiConverterTypeBSAction::write(stream, val.buy_sell);
    FfiConverterString::write(stream, val.symbol);
    FfiConverterOptionalString::write(stream, val.price);
    FfiConverterInt64::write(stream, val.quantity);
    FfiConverterTypeMarketType::write(stream, val.market_type);
    FfiConverterTypePriceType::write(stream, val.price_type);
    FfiConverterTypeTimeInForce::write(stream, val.time_in_force);
    FfiConverterTypeOrderType::write(stream, val.order_type);
    FfiConverterOptionalString::write(stream, val.user_def);
}

int32_t FfiConverterTypeOrder::allocation_size(const Order &val) {
    
    return 
        FfiConverterTypeBSAction::allocation_size(val.buy_sell) +
        FfiConverterString::allocation_size(val.symbol) +
        FfiConverterOptionalString::allocation_size(val.price) +
        FfiConverterInt64::allocation_size(val.quantity) +
        FfiConverterTypeMarketType::allocation_size(val.market_type) +
        FfiConverterTypePriceType::allocation_size(val.price_type) +
        FfiConverterTypeTimeInForce::allocation_size(val.time_in_force) +
        FfiConverterTypeOrderType::allocation_size(val.order_type) +
        FfiConverterOptionalString::allocation_size(val.user_def);
    
}


OrderDetail FfiConverterTypeOrderDetail::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeOrderDetail::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeOrderDetail::lower(const OrderDetail &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeOrderDetail::write(stream, val);

    return std::move(buf);
}

OrderDetail FfiConverterTypeOrderDetail::read(RustStream &stream) {
    return {
        FfiConverterOptionalInt32::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalInt32::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeOrderDetail::write(RustStream &stream, const OrderDetail &val) {
    FfiConverterOptionalInt32::write(stream, val.function_type);
    FfiConverterString::write(stream, val.modified_time);
    FfiConverterOptionalInt64::write(stream, val.before_qty);
    FfiConverterOptionalInt64::write(stream, val.after_qty);
    FfiConverterOptionalDouble::write(stream, val.before_price);
    FfiConverterOptionalDouble::write(stream, val.after_price);
    FfiConverterOptionalDouble::write(stream, val.filled_money);
    FfiConverterOptionalInt32::write(stream, val.status);
    FfiConverterOptionalString::write(stream, val.err_msg);
}

int32_t FfiConverterTypeOrderDetail::allocation_size(const OrderDetail &val) {
    
    return 
        FfiConverterOptionalInt32::allocation_size(val.function_type) +
        FfiConverterString::allocation_size(val.modified_time) +
        FfiConverterOptionalInt64::allocation_size(val.before_qty) +
        FfiConverterOptionalInt64::allocation_size(val.after_qty) +
        FfiConverterOptionalDouble::allocation_size(val.before_price) +
        FfiConverterOptionalDouble::allocation_size(val.after_price) +
        FfiConverterOptionalDouble::allocation_size(val.filled_money) +
        FfiConverterOptionalInt32::allocation_size(val.status) +
        FfiConverterOptionalString::allocation_size(val.err_msg);
    
}


OrderResponse FfiConverterTypeOrderResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeOrderResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeOrderResponse::lower(const OrderResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeOrderResponse::write(stream, val);

    return std::move(buf);
}

OrderResponse FfiConverterTypeOrderResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalTypeOrderResult::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeOrderResponse::write(RustStream &stream, const OrderResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalTypeOrderResult::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeOrderResponse::allocation_size(const OrderResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalTypeOrderResult::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


OrderResult FfiConverterTypeOrderResult::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeOrderResult::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeOrderResult::lower(const OrderResult &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeOrderResult::write(stream, val);

    return std::move(buf);
}

OrderResult FfiConverterTypeOrderResult::read(RustStream &stream) {
    return {
        FfiConverterOptionalInt32::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalInt32::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterTypeMarketType::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalTypeBSAction::read(stream),
        FfiConverterOptionalTypePriceType::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalTypeTimeInForce::read(stream),
        FfiConverterOptionalTypeOrderType::read(stream),
        FfiConverterBool::read(stream),
        FfiConverterOptionalInt32::read(stream),
        FfiConverterOptionalTypePriceType::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalInt32::read(stream),
        FfiConverterOptionalInt32::read(stream),
        FfiConverterOptionalInt32::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt32::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalSequenceTypeOrderDetail::read(stream)
    };
}

void FfiConverterTypeOrderResult::write(RustStream &stream, const OrderResult &val) {
    FfiConverterOptionalInt32::write(stream, val.function_type);
    FfiConverterString::write(stream, val.date);
    FfiConverterString::write(stream, val.seq_no);
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.account);
    FfiConverterOptionalString::write(stream, val.order_no);
    FfiConverterOptionalInt32::write(stream, val.asset_type);
    FfiConverterOptionalString::write(stream, val.market);
    FfiConverterTypeMarketType::write(stream, val.market_type);
    FfiConverterOptionalString::write(stream, val.stock_no);
    FfiConverterOptionalTypeBSAction::write(stream, val.buy_sell);
    FfiConverterOptionalTypePriceType::write(stream, val.price_type);
    FfiConverterOptionalDouble::write(stream, val.price);
    FfiConverterOptionalInt64::write(stream, val.quantity);
    FfiConverterOptionalTypeTimeInForce::write(stream, val.time_in_force);
    FfiConverterOptionalTypeOrderType::write(stream, val.order_type);
    FfiConverterBool::write(stream, val.is_pre_order);
    FfiConverterOptionalInt32::write(stream, val.status);
    FfiConverterOptionalTypePriceType::write(stream, val.after_price_type);
    FfiConverterOptionalDouble::write(stream, val.after_price);
    FfiConverterOptionalInt32::write(stream, val.unit);
    FfiConverterOptionalInt32::write(stream, val.after_qty);
    FfiConverterOptionalInt32::write(stream, val.filled_qty);
    FfiConverterOptionalInt64::write(stream, val.filled_money);
    FfiConverterOptionalInt32::write(stream, val.before_qty);
    FfiConverterOptionalDouble::write(stream, val.before_price);
    FfiConverterOptionalString::write(stream, val.user_def);
    FfiConverterString::write(stream, val.last_time);
    FfiConverterOptionalString::write(stream, val.error_message);
    FfiConverterOptionalSequenceTypeOrderDetail::write(stream, val.details);
}

int32_t FfiConverterTypeOrderResult::allocation_size(const OrderResult &val) {
    
    return 
        FfiConverterOptionalInt32::allocation_size(val.function_type) +
        FfiConverterString::allocation_size(val.date) +
        FfiConverterString::allocation_size(val.seq_no) +
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterOptionalString::allocation_size(val.order_no) +
        FfiConverterOptionalInt32::allocation_size(val.asset_type) +
        FfiConverterOptionalString::allocation_size(val.market) +
        FfiConverterTypeMarketType::allocation_size(val.market_type) +
        FfiConverterOptionalString::allocation_size(val.stock_no) +
        FfiConverterOptionalTypeBSAction::allocation_size(val.buy_sell) +
        FfiConverterOptionalTypePriceType::allocation_size(val.price_type) +
        FfiConverterOptionalDouble::allocation_size(val.price) +
        FfiConverterOptionalInt64::allocation_size(val.quantity) +
        FfiConverterOptionalTypeTimeInForce::allocation_size(val.time_in_force) +
        FfiConverterOptionalTypeOrderType::allocation_size(val.order_type) +
        FfiConverterBool::allocation_size(val.is_pre_order) +
        FfiConverterOptionalInt32::allocation_size(val.status) +
        FfiConverterOptionalTypePriceType::allocation_size(val.after_price_type) +
        FfiConverterOptionalDouble::allocation_size(val.after_price) +
        FfiConverterOptionalInt32::allocation_size(val.unit) +
        FfiConverterOptionalInt32::allocation_size(val.after_qty) +
        FfiConverterOptionalInt32::allocation_size(val.filled_qty) +
        FfiConverterOptionalInt64::allocation_size(val.filled_money) +
        FfiConverterOptionalInt32::allocation_size(val.before_qty) +
        FfiConverterOptionalDouble::allocation_size(val.before_price) +
        FfiConverterOptionalString::allocation_size(val.user_def) +
        FfiConverterString::allocation_size(val.last_time) +
        FfiConverterOptionalString::allocation_size(val.error_message) +
        FfiConverterOptionalSequenceTypeOrderDetail::allocation_size(val.details);
    
}


ParentChildRecord FfiConverterTypeParentChildRecord::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeParentChildRecord::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeParentChildRecord::lower(const ParentChildRecord &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeParentChildRecord::write(stream, val);

    return std::move(buf);
}

ParentChildRecord FfiConverterTypeParentChildRecord::read(RustStream &stream) {
    return {
        FfiConverterOptionalString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream)
    };
}

void FfiConverterTypeParentChildRecord::write(RustStream &stream, const ParentChildRecord &val) {
    FfiConverterOptionalString::write(stream, val.guid);
    FfiConverterString::write(stream, val.account);
    FfiConverterString::write(stream, val.condition_content);
    FfiConverterString::write(stream, val.action);
    FfiConverterString::write(stream, val.condition_buy_sell);
    FfiConverterString::write(stream, val.condition_symbol);
    FfiConverterString::write(stream, val.condition_price);
    FfiConverterString::write(stream, val.condition_volume);
    FfiConverterString::write(stream, val.condition_filled_volume);
    FfiConverterString::write(stream, val.start_date);
    FfiConverterString::write(stream, val.status);
    FfiConverterString::write(stream, val.error_message);
}

int32_t FfiConverterTypeParentChildRecord::allocation_size(const ParentChildRecord &val) {
    
    return 
        FfiConverterOptionalString::allocation_size(val.guid) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterString::allocation_size(val.condition_content) +
        FfiConverterString::allocation_size(val.action) +
        FfiConverterString::allocation_size(val.condition_buy_sell) +
        FfiConverterString::allocation_size(val.condition_symbol) +
        FfiConverterString::allocation_size(val.condition_price) +
        FfiConverterString::allocation_size(val.condition_volume) +
        FfiConverterString::allocation_size(val.condition_filled_volume) +
        FfiConverterString::allocation_size(val.start_date) +
        FfiConverterString::allocation_size(val.status) +
        FfiConverterString::allocation_size(val.error_message);
    
}


Position FfiConverterTypePosition::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePosition::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePosition::lower(const Position &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePosition::write(stream, val);

    return std::move(buf);
}

Position FfiConverterTypePosition::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalTypeCallPut::read(stream),
        FfiConverterTypeBSAction::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterInt64::read(stream),
        FfiConverterInt64::read(stream),
        FfiConverterOptionalTypeFutOptOrderType::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterString::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream)
    };
}

void FfiConverterTypePosition::write(RustStream &stream, const Position &val) {
    FfiConverterString::write(stream, val.date);
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.account);
    FfiConverterInt32::write(stream, val.position_kind);
    FfiConverterString::write(stream, val.order_no);
    FfiConverterString::write(stream, val.symbol);
    FfiConverterString::write(stream, val.expiry_date);
    FfiConverterOptionalDouble::write(stream, val.strike_price);
    FfiConverterOptionalTypeCallPut::write(stream, val.call_put);
    FfiConverterTypeBSAction::write(stream, val.buy_sell);
    FfiConverterOptionalDouble::write(stream, val.price);
    FfiConverterInt64::write(stream, val.orig_lots);
    FfiConverterInt64::write(stream, val.tradable_lot);
    FfiConverterOptionalTypeFutOptOrderType::write(stream, val.order_type);
    FfiConverterOptionalString::write(stream, val.currency);
    FfiConverterDouble::write(stream, val.profit_or_loss);
    FfiConverterString::write(stream, val.market_price);
    FfiConverterDouble::write(stream, val.initial_margin);
    FfiConverterDouble::write(stream, val.maintenance_margin);
    FfiConverterDouble::write(stream, val.clearing_margin);
    FfiConverterDouble::write(stream, val.premium);
}

int32_t FfiConverterTypePosition::allocation_size(const Position &val) {
    
    return 
        FfiConverterString::allocation_size(val.date) +
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterInt32::allocation_size(val.position_kind) +
        FfiConverterString::allocation_size(val.order_no) +
        FfiConverterString::allocation_size(val.symbol) +
        FfiConverterString::allocation_size(val.expiry_date) +
        FfiConverterOptionalDouble::allocation_size(val.strike_price) +
        FfiConverterOptionalTypeCallPut::allocation_size(val.call_put) +
        FfiConverterTypeBSAction::allocation_size(val.buy_sell) +
        FfiConverterOptionalDouble::allocation_size(val.price) +
        FfiConverterInt64::allocation_size(val.orig_lots) +
        FfiConverterInt64::allocation_size(val.tradable_lot) +
        FfiConverterOptionalTypeFutOptOrderType::allocation_size(val.order_type) +
        FfiConverterOptionalString::allocation_size(val.currency) +
        FfiConverterDouble::allocation_size(val.profit_or_loss) +
        FfiConverterString::allocation_size(val.market_price) +
        FfiConverterDouble::allocation_size(val.initial_margin) +
        FfiConverterDouble::allocation_size(val.maintenance_margin) +
        FfiConverterDouble::allocation_size(val.clearing_margin) +
        FfiConverterDouble::allocation_size(val.premium);
    
}


Realized FfiConverterTypeRealized::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeRealized::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeRealized::lower(const Realized &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeRealized::write(stream, val);

    return std::move(buf);
}

Realized FfiConverterTypeRealized::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeBSAction::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterTypeOrderType::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream)
    };
}

void FfiConverterTypeRealized::write(RustStream &stream, const Realized &val) {
    FfiConverterString::write(stream, val.date);
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.account);
    FfiConverterString::write(stream, val.stock_no);
    FfiConverterTypeBSAction::write(stream, val.buy_sell);
    FfiConverterInt32::write(stream, val.filled_qty);
    FfiConverterDouble::write(stream, val.filled_price);
    FfiConverterTypeOrderType::write(stream, val.order_type);
    FfiConverterInt32::write(stream, val.realized_profit);
    FfiConverterInt32::write(stream, val.realized_loss);
}

int32_t FfiConverterTypeRealized::allocation_size(const Realized &val) {
    
    return 
        FfiConverterString::allocation_size(val.date) +
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterString::allocation_size(val.stock_no) +
        FfiConverterTypeBSAction::allocation_size(val.buy_sell) +
        FfiConverterInt32::allocation_size(val.filled_qty) +
        FfiConverterDouble::allocation_size(val.filled_price) +
        FfiConverterTypeOrderType::allocation_size(val.order_type) +
        FfiConverterInt32::allocation_size(val.realized_profit) +
        FfiConverterInt32::allocation_size(val.realized_loss);
    
}


RealizedResponse FfiConverterTypeRealizedResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeRealizedResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeRealizedResponse::lower(const RealizedResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeRealizedResponse::write(stream, val);

    return std::move(buf);
}

RealizedResponse FfiConverterTypeRealizedResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalSequenceTypeRealized::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeRealizedResponse::write(RustStream &stream, const RealizedResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalSequenceTypeRealized::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeRealizedResponse::allocation_size(const RealizedResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalSequenceTypeRealized::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


RealizedSummary FfiConverterTypeRealizedSummary::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeRealizedSummary::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeRealizedSummary::lower(const RealizedSummary &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeRealizedSummary::write(stream, val);

    return std::move(buf);
}

RealizedSummary FfiConverterTypeRealizedSummary::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeBSAction::read(stream),
        FfiConverterTypeOrderType::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterInt64::read(stream)
    };
}

void FfiConverterTypeRealizedSummary::write(RustStream &stream, const RealizedSummary &val) {
    FfiConverterString::write(stream, val.start_date);
    FfiConverterString::write(stream, val.end_date);
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.account);
    FfiConverterString::write(stream, val.stock_no);
    FfiConverterTypeBSAction::write(stream, val.buy_sell);
    FfiConverterTypeOrderType::write(stream, val.order_type);
    FfiConverterInt32::write(stream, val.filled_qty);
    FfiConverterDouble::write(stream, val.filled_avg_price);
    FfiConverterInt64::write(stream, val.realized_profit_and_loss);
}

int32_t FfiConverterTypeRealizedSummary::allocation_size(const RealizedSummary &val) {
    
    return 
        FfiConverterString::allocation_size(val.start_date) +
        FfiConverterString::allocation_size(val.end_date) +
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterString::allocation_size(val.stock_no) +
        FfiConverterTypeBSAction::allocation_size(val.buy_sell) +
        FfiConverterTypeOrderType::allocation_size(val.order_type) +
        FfiConverterInt32::allocation_size(val.filled_qty) +
        FfiConverterDouble::allocation_size(val.filled_avg_price) +
        FfiConverterInt64::allocation_size(val.realized_profit_and_loss);
    
}


RealizedSummaryResponse FfiConverterTypeRealizedSummaryResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeRealizedSummaryResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeRealizedSummaryResponse::lower(const RealizedSummaryResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeRealizedSummaryResponse::write(stream, val);

    return std::move(buf);
}

RealizedSummaryResponse FfiConverterTypeRealizedSummaryResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalSequenceTypeRealizedSummary::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeRealizedSummaryResponse::write(RustStream &stream, const RealizedSummaryResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalSequenceTypeRealizedSummary::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeRealizedSummaryResponse::allocation_size(const RealizedSummaryResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalSequenceTypeRealizedSummary::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


Recover FfiConverterTypeRecover::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeRecover::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeRecover::lower(const Recover &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeRecover::write(stream, val);

    return std::move(buf);
}

Recover FfiConverterTypeRecover::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterInt64::read(stream)
    };
}

void FfiConverterTypeRecover::write(RustStream &stream, const Recover &val) {
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.account);
    FfiConverterString::write(stream, val.account_type);
    FfiConverterString::write(stream, val.recover_type);
    FfiConverterInt64::write(stream, val.recover_count);
}

int32_t FfiConverterTypeRecover::allocation_size(const Recover &val) {
    
    return 
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterString::allocation_size(val.account_type) +
        FfiConverterString::allocation_size(val.recover_type) +
        FfiConverterInt64::allocation_size(val.recover_count);
    
}


Reply FfiConverterTypeReply::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeReply::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeReply::lower(const Reply &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeReply::write(stream, val);

    return std::move(buf);
}

Reply FfiConverterTypeReply::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream)
    };
}

void FfiConverterTypeReply::write(RustStream &stream, const Reply &val) {
    FfiConverterString::write(stream, val.reply_code);
    FfiConverterString::write(stream, val.advisory);
}

int32_t FfiConverterTypeReply::allocation_size(const Reply &val) {
    
    return 
        FfiConverterString::allocation_size(val.reply_code) +
        FfiConverterString::allocation_size(val.advisory);
    
}


SdkRef FfiConverterTypeSdkRef::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSdkRef::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeSdkRef::lower(const SdkRef &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSdkRef::write(stream, val);

    return std::move(buf);
}

SdkRef FfiConverterTypeSdkRef::read(RustStream &stream) {
    return {
        FfiConverterStockFunctions::read(stream),
        FfiConverterAccounting::read(stream),
        FfiConverterFutOptFunctions::read(stream),
        FfiConverterFutOptAccounting::read(stream)
    };
}

void FfiConverterTypeSdkRef::write(RustStream &stream, const SdkRef &val) {
    FfiConverterStockFunctions::write(stream, val.stock);
    FfiConverterAccounting::write(stream, val.accounting);
    FfiConverterFutOptFunctions::write(stream, val.futopt);
    FfiConverterFutOptAccounting::write(stream, val.futopt_accounting);
}

int32_t FfiConverterTypeSdkRef::allocation_size(const SdkRef &val) {
    
    return 
        FfiConverterStockFunctions::allocation_size(val.stock) +
        FfiConverterAccounting::allocation_size(val.accounting) +
        FfiConverterFutOptFunctions::allocation_size(val.futopt) +
        FfiConverterFutOptAccounting::allocation_size(val.futopt_accounting);
    
}


Settlement FfiConverterTypeSettlement::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSettlement::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeSettlement::lower(const Settlement &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSettlement::write(stream, val);

    return std::move(buf);
}

Settlement FfiConverterTypeSettlement::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeSettlement::write(RustStream &stream, const Settlement &val) {
    FfiConverterString::write(stream, val.date);
    FfiConverterOptionalString::write(stream, val.settlement_date);
    FfiConverterOptionalInt64::write(stream, val.buy_value);
    FfiConverterOptionalInt64::write(stream, val.buy_fee);
    FfiConverterOptionalInt64::write(stream, val.buy_settlement);
    FfiConverterOptionalInt64::write(stream, val.buy_tax);
    FfiConverterOptionalInt64::write(stream, val.sell_value);
    FfiConverterOptionalInt64::write(stream, val.sell_fee);
    FfiConverterOptionalInt64::write(stream, val.sell_settlement);
    FfiConverterOptionalInt64::write(stream, val.sell_tax);
    FfiConverterOptionalInt64::write(stream, val.total_bs_value);
    FfiConverterOptionalInt64::write(stream, val.total_fee);
    FfiConverterOptionalInt64::write(stream, val.total_tax);
    FfiConverterOptionalInt64::write(stream, val.total_settlement_amount);
    FfiConverterOptionalString::write(stream, val.currency);
}

int32_t FfiConverterTypeSettlement::allocation_size(const Settlement &val) {
    
    return 
        FfiConverterString::allocation_size(val.date) +
        FfiConverterOptionalString::allocation_size(val.settlement_date) +
        FfiConverterOptionalInt64::allocation_size(val.buy_value) +
        FfiConverterOptionalInt64::allocation_size(val.buy_fee) +
        FfiConverterOptionalInt64::allocation_size(val.buy_settlement) +
        FfiConverterOptionalInt64::allocation_size(val.buy_tax) +
        FfiConverterOptionalInt64::allocation_size(val.sell_value) +
        FfiConverterOptionalInt64::allocation_size(val.sell_fee) +
        FfiConverterOptionalInt64::allocation_size(val.sell_settlement) +
        FfiConverterOptionalInt64::allocation_size(val.sell_tax) +
        FfiConverterOptionalInt64::allocation_size(val.total_bs_value) +
        FfiConverterOptionalInt64::allocation_size(val.total_fee) +
        FfiConverterOptionalInt64::allocation_size(val.total_tax) +
        FfiConverterOptionalInt64::allocation_size(val.total_settlement_amount) +
        FfiConverterOptionalString::allocation_size(val.currency);
    
}


SettlementData FfiConverterTypeSettlementData::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSettlementData::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeSettlementData::lower(const SettlementData &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSettlementData::write(stream, val);

    return std::move(buf);
}

SettlementData FfiConverterTypeSettlementData::read(RustStream &stream) {
    return {
        FfiConverterTypeAccountRes::read(stream),
        FfiConverterOptionalSequenceTypeSettlement::read(stream)
    };
}

void FfiConverterTypeSettlementData::write(RustStream &stream, const SettlementData &val) {
    FfiConverterTypeAccountRes::write(stream, val.account);
    FfiConverterOptionalSequenceTypeSettlement::write(stream, val.details);
}

int32_t FfiConverterTypeSettlementData::allocation_size(const SettlementData &val) {
    
    return 
        FfiConverterTypeAccountRes::allocation_size(val.account) +
        FfiConverterOptionalSequenceTypeSettlement::allocation_size(val.details);
    
}


SettlementResponse FfiConverterTypeSettlementResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSettlementResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeSettlementResponse::lower(const SettlementResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSettlementResponse::write(stream, val);

    return std::move(buf);
}

SettlementResponse FfiConverterTypeSettlementResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalTypeSettlementData::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeSettlementResponse::write(RustStream &stream, const SettlementResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalTypeSettlementData::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeSettlementResponse::allocation_size(const SettlementResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalTypeSettlementData::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


SplitDescription FfiConverterTypeSplitDescription::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSplitDescription::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeSplitDescription::lower(const SplitDescription &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSplitDescription::write(stream, val);

    return std::move(buf);
}

SplitDescription FfiConverterTypeSplitDescription::read(RustStream &stream) {
    return {
        FfiConverterTypeTimeSliceOrderType::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeSplitDescription::write(RustStream &stream, const SplitDescription &val) {
    FfiConverterTypeTimeSliceOrderType::write(stream, val.method);
    FfiConverterInt32::write(stream, val.interval);
    FfiConverterInt64::write(stream, val.single_quantity);
    FfiConverterOptionalInt64::write(stream, val.total_quantity);
    FfiConverterString::write(stream, val.start_time);
    FfiConverterOptionalString::write(stream, val.end_time);
}

int32_t FfiConverterTypeSplitDescription::allocation_size(const SplitDescription &val) {
    
    return 
        FfiConverterTypeTimeSliceOrderType::allocation_size(val.method) +
        FfiConverterInt32::allocation_size(val.interval) +
        FfiConverterInt64::allocation_size(val.single_quantity) +
        FfiConverterOptionalInt64::allocation_size(val.total_quantity) +
        FfiConverterString::allocation_size(val.start_time) +
        FfiConverterOptionalString::allocation_size(val.end_time);
    
}


SpreadPosition FfiConverterTypeSpreadPosition::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSpreadPosition::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeSpreadPosition::lower(const SpreadPosition &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSpreadPosition::write(stream, val);

    return std::move(buf);
}

SpreadPosition FfiConverterTypeSpreadPosition::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalTypeCallPut::read(stream),
        FfiConverterTypeBSAction::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterInt64::read(stream),
        FfiConverterInt64::read(stream),
        FfiConverterOptionalTypeFutOptOrderType::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterDouble::read(stream)
    };
}

void FfiConverterTypeSpreadPosition::write(RustStream &stream, const SpreadPosition &val) {
    FfiConverterString::write(stream, val.date);
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.account);
    FfiConverterInt32::write(stream, val.position_kind);
    FfiConverterString::write(stream, val.symbol);
    FfiConverterString::write(stream, val.expiry_date);
    FfiConverterOptionalDouble::write(stream, val.strike_price);
    FfiConverterOptionalTypeCallPut::write(stream, val.call_put);
    FfiConverterTypeBSAction::write(stream, val.buy_sell);
    FfiConverterOptionalDouble::write(stream, val.price);
    FfiConverterInt64::write(stream, val.orig_lots);
    FfiConverterInt64::write(stream, val.tradable_lot);
    FfiConverterOptionalTypeFutOptOrderType::write(stream, val.order_type);
    FfiConverterOptionalString::write(stream, val.currency);
    FfiConverterString::write(stream, val.market_price);
    FfiConverterDouble::write(stream, val.initial_margin);
    FfiConverterDouble::write(stream, val.maintenance_margin);
    FfiConverterDouble::write(stream, val.clearing_margin);
    FfiConverterDouble::write(stream, val.initial_margin_all_single);
    FfiConverterDouble::write(stream, val.opt_value);
    FfiConverterDouble::write(stream, val.opt_long_value);
    FfiConverterDouble::write(stream, val.opt_short_value);
    FfiConverterDouble::write(stream, val.profit_or_loss);
    FfiConverterDouble::write(stream, val.premium);
}

int32_t FfiConverterTypeSpreadPosition::allocation_size(const SpreadPosition &val) {
    
    return 
        FfiConverterString::allocation_size(val.date) +
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterInt32::allocation_size(val.position_kind) +
        FfiConverterString::allocation_size(val.symbol) +
        FfiConverterString::allocation_size(val.expiry_date) +
        FfiConverterOptionalDouble::allocation_size(val.strike_price) +
        FfiConverterOptionalTypeCallPut::allocation_size(val.call_put) +
        FfiConverterTypeBSAction::allocation_size(val.buy_sell) +
        FfiConverterOptionalDouble::allocation_size(val.price) +
        FfiConverterInt64::allocation_size(val.orig_lots) +
        FfiConverterInt64::allocation_size(val.tradable_lot) +
        FfiConverterOptionalTypeFutOptOrderType::allocation_size(val.order_type) +
        FfiConverterOptionalString::allocation_size(val.currency) +
        FfiConverterString::allocation_size(val.market_price) +
        FfiConverterDouble::allocation_size(val.initial_margin) +
        FfiConverterDouble::allocation_size(val.maintenance_margin) +
        FfiConverterDouble::allocation_size(val.clearing_margin) +
        FfiConverterDouble::allocation_size(val.initial_margin_all_single) +
        FfiConverterDouble::allocation_size(val.opt_value) +
        FfiConverterDouble::allocation_size(val.opt_long_value) +
        FfiConverterDouble::allocation_size(val.opt_short_value) +
        FfiConverterDouble::allocation_size(val.profit_or_loss) +
        FfiConverterDouble::allocation_size(val.premium);
    
}


StringResponse FfiConverterTypeStringResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeStringResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeStringResponse::lower(const StringResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeStringResponse::write(stream, val);

    return std::move(buf);
}

StringResponse FfiConverterTypeStringResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeStringResponse::write(RustStream &stream, const StringResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalString::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeStringResponse::allocation_size(const StringResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalString::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


SymbolQuote FfiConverterTypeSymbolQuote::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSymbolQuote::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeSymbolQuote::lower(const SymbolQuote &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSymbolQuote::write(stream, val);

    return std::move(buf);
}

SymbolQuote FfiConverterTypeSymbolQuote::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterBool::read(stream),
        FfiConverterTypeMarketType::read(stream),
        FfiConverterOptionalInt32::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalInt64::read(stream),
        FfiConverterOptionalDouble::read(stream),
        FfiConverterOptionalInt64::read(stream)
    };
}

void FfiConverterTypeSymbolQuote::write(RustStream &stream, const SymbolQuote &val) {
    FfiConverterString::write(stream, val.market);
    FfiConverterString::write(stream, val.symbol);
    FfiConverterBool::write(stream, val.istib_or_psb);
    FfiConverterTypeMarketType::write(stream, val.market_type);
    FfiConverterOptionalInt32::write(stream, val.status);
    FfiConverterOptionalDouble::write(stream, val.reference_price);
    FfiConverterInt32::write(stream, val.unit);
    FfiConverterString::write(stream, val.update_time);
    FfiConverterOptionalDouble::write(stream, val.limitup_price);
    FfiConverterOptionalDouble::write(stream, val.limitdown_price);
    FfiConverterOptionalDouble::write(stream, val.open_price);
    FfiConverterOptionalDouble::write(stream, val.high_price);
    FfiConverterOptionalDouble::write(stream, val.low_price);
    FfiConverterOptionalDouble::write(stream, val.last_price);
    FfiConverterOptionalInt64::write(stream, val.total_volume);
    FfiConverterOptionalInt64::write(stream, val.total_transaction);
    FfiConverterOptionalInt64::write(stream, val.total_value);
    FfiConverterOptionalInt64::write(stream, val.last_size);
    FfiConverterOptionalInt64::write(stream, val.last_transaction);
    FfiConverterOptionalInt64::write(stream, val.last_value);
    FfiConverterOptionalDouble::write(stream, val.bid_price);
    FfiConverterOptionalInt64::write(stream, val.bid_volume);
    FfiConverterOptionalDouble::write(stream, val.ask_price);
    FfiConverterOptionalInt64::write(stream, val.ask_volume);
}

int32_t FfiConverterTypeSymbolQuote::allocation_size(const SymbolQuote &val) {
    
    return 
        FfiConverterString::allocation_size(val.market) +
        FfiConverterString::allocation_size(val.symbol) +
        FfiConverterBool::allocation_size(val.istib_or_psb) +
        FfiConverterTypeMarketType::allocation_size(val.market_type) +
        FfiConverterOptionalInt32::allocation_size(val.status) +
        FfiConverterOptionalDouble::allocation_size(val.reference_price) +
        FfiConverterInt32::allocation_size(val.unit) +
        FfiConverterString::allocation_size(val.update_time) +
        FfiConverterOptionalDouble::allocation_size(val.limitup_price) +
        FfiConverterOptionalDouble::allocation_size(val.limitdown_price) +
        FfiConverterOptionalDouble::allocation_size(val.open_price) +
        FfiConverterOptionalDouble::allocation_size(val.high_price) +
        FfiConverterOptionalDouble::allocation_size(val.low_price) +
        FfiConverterOptionalDouble::allocation_size(val.last_price) +
        FfiConverterOptionalInt64::allocation_size(val.total_volume) +
        FfiConverterOptionalInt64::allocation_size(val.total_transaction) +
        FfiConverterOptionalInt64::allocation_size(val.total_value) +
        FfiConverterOptionalInt64::allocation_size(val.last_size) +
        FfiConverterOptionalInt64::allocation_size(val.last_transaction) +
        FfiConverterOptionalInt64::allocation_size(val.last_value) +
        FfiConverterOptionalDouble::allocation_size(val.bid_price) +
        FfiConverterOptionalInt64::allocation_size(val.bid_volume) +
        FfiConverterOptionalDouble::allocation_size(val.ask_price) +
        FfiConverterOptionalInt64::allocation_size(val.ask_volume);
    
}


SymbolQuoteResponse FfiConverterTypeSymbolQuoteResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSymbolQuoteResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeSymbolQuoteResponse::lower(const SymbolQuoteResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSymbolQuoteResponse::write(stream, val);

    return std::move(buf);
}

SymbolQuoteResponse FfiConverterTypeSymbolQuoteResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalTypeSymbolQuote::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeSymbolQuoteResponse::write(RustStream &stream, const SymbolQuoteResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalTypeSymbolQuote::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeSymbolQuoteResponse::allocation_size(const SymbolQuoteResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalTypeSymbolQuote::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


TpslOrder FfiConverterTypeTPSLOrder::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTPSLOrder::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTPSLOrder::lower(const TpslOrder &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTPSLOrder::write(stream, val);

    return std::move(buf);
}

TpslOrder FfiConverterTypeTPSLOrder::read(RustStream &stream) {
    return {
        FfiConverterTypeTimeInForce::read(stream),
        FfiConverterTypeConditionPriceType::read(stream),
        FfiConverterTypeConditionOrderType::read(stream),
        FfiConverterString::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalTypeTriggerContent::read(stream)
    };
}

void FfiConverterTypeTPSLOrder::write(RustStream &stream, const TpslOrder &val) {
    FfiConverterTypeTimeInForce::write(stream, val.time_in_force);
    FfiConverterTypeConditionPriceType::write(stream, val.price_type);
    FfiConverterTypeConditionOrderType::write(stream, val.order_type);
    FfiConverterString::write(stream, val.target_price);
    FfiConverterOptionalString::write(stream, val.price);
    FfiConverterOptionalTypeTriggerContent::write(stream, val.trigger);
}

int32_t FfiConverterTypeTPSLOrder::allocation_size(const TpslOrder &val) {
    
    return 
        FfiConverterTypeTimeInForce::allocation_size(val.time_in_force) +
        FfiConverterTypeConditionPriceType::allocation_size(val.price_type) +
        FfiConverterTypeConditionOrderType::allocation_size(val.order_type) +
        FfiConverterString::allocation_size(val.target_price) +
        FfiConverterOptionalString::allocation_size(val.price) +
        FfiConverterOptionalTypeTriggerContent::allocation_size(val.trigger);
    
}


TPSLWrapper FfiConverterTypeTPSLWrapper::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTPSLWrapper::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTPSLWrapper::lower(const TPSLWrapper &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTPSLWrapper::write(stream, val);

    return std::move(buf);
}

TPSLWrapper FfiConverterTypeTPSLWrapper::read(RustStream &stream) {
    return {
        FfiConverterTypeStopSign::read(stream),
        FfiConverterOptionalTypeTPSLOrder::read(stream),
        FfiConverterOptionalTypeTPSLOrder::read(stream),
        FfiConverterOptionalString::read(stream),
        FfiConverterOptionalBool::read(stream)
    };
}

void FfiConverterTypeTPSLWrapper::write(RustStream &stream, const TPSLWrapper &val) {
    FfiConverterTypeStopSign::write(stream, val.stop_sign);
    FfiConverterOptionalTypeTPSLOrder::write(stream, val.tp);
    FfiConverterOptionalTypeTPSLOrder::write(stream, val.sl);
    FfiConverterOptionalString::write(stream, val.end_date);
    FfiConverterOptionalBool::write(stream, val.intraday);
}

int32_t FfiConverterTypeTPSLWrapper::allocation_size(const TPSLWrapper &val) {
    
    return 
        FfiConverterTypeStopSign::allocation_size(val.stop_sign) +
        FfiConverterOptionalTypeTPSLOrder::allocation_size(val.tp) +
        FfiConverterOptionalTypeTPSLOrder::allocation_size(val.sl) +
        FfiConverterOptionalString::allocation_size(val.end_date) +
        FfiConverterOptionalBool::allocation_size(val.intraday);
    
}


TrailOrder FfiConverterTypeTrailOrder::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTrailOrder::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTrailOrder::lower(const TrailOrder &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTrailOrder::write(stream, val);

    return std::move(buf);
}

TrailOrder FfiConverterTypeTrailOrder::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeDirection::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterTypeBSAction::read(stream),
        FfiConverterInt64::read(stream),
        FfiConverterTypeConditionPriceType::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterTypeTimeInForce::read(stream),
        FfiConverterTypeConditionOrderType::read(stream)
    };
}

void FfiConverterTypeTrailOrder::write(RustStream &stream, const TrailOrder &val) {
    FfiConverterString::write(stream, val.symbol);
    FfiConverterString::write(stream, val.price);
    FfiConverterTypeDirection::write(stream, val.direction);
    FfiConverterInt32::write(stream, val.percentage);
    FfiConverterTypeBSAction::write(stream, val.buy_sell);
    FfiConverterInt64::write(stream, val.quantity);
    FfiConverterTypeConditionPriceType::write(stream, val.price_type);
    FfiConverterInt32::write(stream, val.diff);
    FfiConverterTypeTimeInForce::write(stream, val.time_in_force);
    FfiConverterTypeConditionOrderType::write(stream, val.order_type);
}

int32_t FfiConverterTypeTrailOrder::allocation_size(const TrailOrder &val) {
    
    return 
        FfiConverterString::allocation_size(val.symbol) +
        FfiConverterString::allocation_size(val.price) +
        FfiConverterTypeDirection::allocation_size(val.direction) +
        FfiConverterInt32::allocation_size(val.percentage) +
        FfiConverterTypeBSAction::allocation_size(val.buy_sell) +
        FfiConverterInt64::allocation_size(val.quantity) +
        FfiConverterTypeConditionPriceType::allocation_size(val.price_type) +
        FfiConverterInt32::allocation_size(val.diff) +
        FfiConverterTypeTimeInForce::allocation_size(val.time_in_force) +
        FfiConverterTypeConditionOrderType::allocation_size(val.order_type);
    
}


UnRealizedResponse FfiConverterTypeUnRealizedResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeUnRealizedResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeUnRealizedResponse::lower(const UnRealizedResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeUnRealizedResponse::write(stream, val);

    return std::move(buf);
}

UnRealizedResponse FfiConverterTypeUnRealizedResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalSequenceTypeUnrealized::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeUnRealizedResponse::write(RustStream &stream, const UnRealizedResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalSequenceTypeUnrealized::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeUnRealizedResponse::allocation_size(const UnRealizedResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalSequenceTypeUnrealized::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


Unrealized FfiConverterTypeUnrealized::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeUnrealized::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeUnrealized::lower(const Unrealized &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeUnrealized::write(stream, val);

    return std::move(buf);
}

Unrealized FfiConverterTypeUnrealized::read(RustStream &stream) {
    return {
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterString::read(stream),
        FfiConverterTypeBSAction::read(stream),
        FfiConverterTypeOrderType::read(stream),
        FfiConverterDouble::read(stream),
        FfiConverterInt64::read(stream),
        FfiConverterInt64::read(stream),
        FfiConverterInt32::read(stream),
        FfiConverterInt32::read(stream)
    };
}

void FfiConverterTypeUnrealized::write(RustStream &stream, const Unrealized &val) {
    FfiConverterString::write(stream, val.date);
    FfiConverterString::write(stream, val.account);
    FfiConverterString::write(stream, val.branch_no);
    FfiConverterString::write(stream, val.stock_no);
    FfiConverterTypeBSAction::write(stream, val.buy_sell);
    FfiConverterTypeOrderType::write(stream, val.order_type);
    FfiConverterDouble::write(stream, val.cost_price);
    FfiConverterInt64::write(stream, val.tradable_qty);
    FfiConverterInt64::write(stream, val.today_qty);
    FfiConverterInt32::write(stream, val.unrealized_profit);
    FfiConverterInt32::write(stream, val.unrealized_loss);
}

int32_t FfiConverterTypeUnrealized::allocation_size(const Unrealized &val) {
    
    return 
        FfiConverterString::allocation_size(val.date) +
        FfiConverterString::allocation_size(val.account) +
        FfiConverterString::allocation_size(val.branch_no) +
        FfiConverterString::allocation_size(val.stock_no) +
        FfiConverterTypeBSAction::allocation_size(val.buy_sell) +
        FfiConverterTypeOrderType::allocation_size(val.order_type) +
        FfiConverterDouble::allocation_size(val.cost_price) +
        FfiConverterInt64::allocation_size(val.tradable_qty) +
        FfiConverterInt64::allocation_size(val.today_qty) +
        FfiConverterInt32::allocation_size(val.unrealized_profit) +
        FfiConverterInt32::allocation_size(val.unrealized_loss);
    
}


VecCloseRecordResponse FfiConverterTypeVecCloseRecordResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeVecCloseRecordResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeVecCloseRecordResponse::lower(const VecCloseRecordResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeVecCloseRecordResponse::write(stream, val);

    return std::move(buf);
}

VecCloseRecordResponse FfiConverterTypeVecCloseRecordResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalSequenceTypeCloseRecord::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeVecCloseRecordResponse::write(RustStream &stream, const VecCloseRecordResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalSequenceTypeCloseRecord::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeVecCloseRecordResponse::allocation_size(const VecCloseRecordResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalSequenceTypeCloseRecord::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


VecConditionDetailResponse FfiConverterTypeVecConditionDetailResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeVecConditionDetailResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeVecConditionDetailResponse::lower(const VecConditionDetailResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeVecConditionDetailResponse::write(stream, val);

    return std::move(buf);
}

VecConditionDetailResponse FfiConverterTypeVecConditionDetailResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalSequenceTypeConditionDetail::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeVecConditionDetailResponse::write(RustStream &stream, const VecConditionDetailResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalSequenceTypeConditionDetail::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeVecConditionDetailResponse::allocation_size(const VecConditionDetailResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalSequenceTypeConditionDetail::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


VecEquityResponse FfiConverterTypeVecEquityResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeVecEquityResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeVecEquityResponse::lower(const VecEquityResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeVecEquityResponse::write(stream, val);

    return std::move(buf);
}

VecEquityResponse FfiConverterTypeVecEquityResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalSequenceTypeEquity::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeVecEquityResponse::write(RustStream &stream, const VecEquityResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalSequenceTypeEquity::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeVecEquityResponse::allocation_size(const VecEquityResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalSequenceTypeEquity::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


VecFutOptFilledResponse FfiConverterTypeVecFutOptFilledResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeVecFutOptFilledResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeVecFutOptFilledResponse::lower(const VecFutOptFilledResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeVecFutOptFilledResponse::write(stream, val);

    return std::move(buf);
}

VecFutOptFilledResponse FfiConverterTypeVecFutOptFilledResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalSequenceTypeFutOptFilledData::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeVecFutOptFilledResponse::write(RustStream &stream, const VecFutOptFilledResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalSequenceTypeFutOptFilledData::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeVecFutOptFilledResponse::allocation_size(const VecFutOptFilledResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalSequenceTypeFutOptFilledData::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


VecFutOptHybridPositionResponse FfiConverterTypeVecFutOptHybridPositionResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeVecFutOptHybridPositionResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeVecFutOptHybridPositionResponse::lower(const VecFutOptHybridPositionResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeVecFutOptHybridPositionResponse::write(stream, val);

    return std::move(buf);
}

VecFutOptHybridPositionResponse FfiConverterTypeVecFutOptHybridPositionResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalSequenceTypeHybridPosition::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeVecFutOptHybridPositionResponse::write(RustStream &stream, const VecFutOptHybridPositionResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalSequenceTypeHybridPosition::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeVecFutOptHybridPositionResponse::allocation_size(const VecFutOptHybridPositionResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalSequenceTypeHybridPosition::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


VecFutOptOrderResponse FfiConverterTypeVecFutOptOrderResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeVecFutOptOrderResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeVecFutOptOrderResponse::lower(const VecFutOptOrderResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeVecFutOptOrderResponse::write(stream, val);

    return std::move(buf);
}

VecFutOptOrderResponse FfiConverterTypeVecFutOptOrderResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalSequenceTypeFutOptOrderResult::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeVecFutOptOrderResponse::write(RustStream &stream, const VecFutOptOrderResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalSequenceTypeFutOptOrderResult::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeVecFutOptOrderResponse::allocation_size(const VecFutOptOrderResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalSequenceTypeFutOptOrderResult::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


VecFutOptPositionResponse FfiConverterTypeVecFutOptPositionResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeVecFutOptPositionResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeVecFutOptPositionResponse::lower(const VecFutOptPositionResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeVecFutOptPositionResponse::write(stream, val);

    return std::move(buf);
}

VecFutOptPositionResponse FfiConverterTypeVecFutOptPositionResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalSequenceTypePosition::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeVecFutOptPositionResponse::write(RustStream &stream, const VecFutOptPositionResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalSequenceTypePosition::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeVecFutOptPositionResponse::allocation_size(const VecFutOptPositionResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalSequenceTypePosition::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


VecOrderResponse FfiConverterTypeVecOrderResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeVecOrderResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeVecOrderResponse::lower(const VecOrderResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeVecOrderResponse::write(stream, val);

    return std::move(buf);
}

VecOrderResponse FfiConverterTypeVecOrderResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalSequenceTypeOrderResult::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeVecOrderResponse::write(RustStream &stream, const VecOrderResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalSequenceTypeOrderResult::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeVecOrderResponse::allocation_size(const VecOrderResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalSequenceTypeOrderResult::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


VecRecoverResponse FfiConverterTypeVecRecoverResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeVecRecoverResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeVecRecoverResponse::lower(const VecRecoverResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeVecRecoverResponse::write(stream, val);

    return std::move(buf);
}

VecRecoverResponse FfiConverterTypeVecRecoverResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalSequenceTypeRecover::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeVecRecoverResponse::write(RustStream &stream, const VecRecoverResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalSequenceTypeRecover::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeVecRecoverResponse::allocation_size(const VecRecoverResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalSequenceTypeRecover::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


VecSymbolQuoteResponse FfiConverterTypeVecSymbolQuoteResponse::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeVecSymbolQuoteResponse::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeVecSymbolQuoteResponse::lower(const VecSymbolQuoteResponse &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeVecSymbolQuoteResponse::write(stream, val);

    return std::move(buf);
}

VecSymbolQuoteResponse FfiConverterTypeVecSymbolQuoteResponse::read(RustStream &stream) {
    return {
        FfiConverterBool::read(stream),
        FfiConverterOptionalSequenceTypeSymbolQuote::read(stream),
        FfiConverterOptionalString::read(stream)
    };
}

void FfiConverterTypeVecSymbolQuoteResponse::write(RustStream &stream, const VecSymbolQuoteResponse &val) {
    FfiConverterBool::write(stream, val.is_success);
    FfiConverterOptionalSequenceTypeSymbolQuote::write(stream, val.data);
    FfiConverterOptionalString::write(stream, val.message);
}

int32_t FfiConverterTypeVecSymbolQuoteResponse::allocation_size(const VecSymbolQuoteResponse &val) {
    
    return 
        FfiConverterBool::allocation_size(val.is_success) +
        FfiConverterOptionalSequenceTypeSymbolQuote::allocation_size(val.data) +
        FfiConverterOptionalString::allocation_size(val.message);
    
}


BsAction FfiConverterTypeBSAction::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeBSAction::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeBSAction::lower(const BsAction &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeBSAction::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeBSAction::write(stream, val);

    return std::move(buf);
}

BsAction FfiConverterTypeBSAction::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return BsAction::BUY;
        
    case 2:
        return BsAction::SELL;
        
    case 3:
        return BsAction::UN_SUPPORTED;
        
    case 4:
        return BsAction::UN_DEFINED;
        
    default:
        throw std::runtime_error("No matching BsAction variant");
    }
}

void FfiConverterTypeBSAction::write(RustStream &stream, const BsAction &val) {
    switch (val) {
        
    case BsAction::BUY:
        stream << static_cast<int32_t>(1);
        break;
        
    case BsAction::SELL:
        stream << static_cast<int32_t>(2);
        break;
        
    case BsAction::UN_SUPPORTED:
        stream << static_cast<int32_t>(3);
        break;
        
    case BsAction::UN_DEFINED:
        stream << static_cast<int32_t>(4);
        break;
        
    default:
        throw std::runtime_error("No matching BsAction variant");
    }
}

int32_t FfiConverterTypeBSAction::allocation_size(const BsAction &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


CallPut FfiConverterTypeCallPut::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeCallPut::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeCallPut::lower(const CallPut &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeCallPut::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeCallPut::write(stream, val);

    return std::move(buf);
}

CallPut FfiConverterTypeCallPut::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return CallPut::CALL;
        
    case 2:
        return CallPut::PUT;
        
    case 3:
        return CallPut::UN_SUPPORTED;
        
    case 4:
        return CallPut::UN_DEFINED;
        
    default:
        throw std::runtime_error("No matching CallPut variant");
    }
}

void FfiConverterTypeCallPut::write(RustStream &stream, const CallPut &val) {
    switch (val) {
        
    case CallPut::CALL:
        stream << static_cast<int32_t>(1);
        break;
        
    case CallPut::PUT:
        stream << static_cast<int32_t>(2);
        break;
        
    case CallPut::UN_SUPPORTED:
        stream << static_cast<int32_t>(3);
        break;
        
    case CallPut::UN_DEFINED:
        stream << static_cast<int32_t>(4);
        break;
        
    default:
        throw std::runtime_error("No matching CallPut variant");
    }
}

int32_t FfiConverterTypeCallPut::allocation_size(const CallPut &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


ConditionMarketType FfiConverterTypeConditionMarketType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeConditionMarketType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeConditionMarketType::lower(const ConditionMarketType &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeConditionMarketType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeConditionMarketType::write(stream, val);

    return std::move(buf);
}

ConditionMarketType FfiConverterTypeConditionMarketType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return ConditionMarketType::COMMON;
        
    case 2:
        return ConditionMarketType::FIXING;
        
    case 3:
        return ConditionMarketType::ODD;
        
    case 4:
        return ConditionMarketType::INTRADAY_ODD;
        
    default:
        throw std::runtime_error("No matching ConditionMarketType variant");
    }
}

void FfiConverterTypeConditionMarketType::write(RustStream &stream, const ConditionMarketType &val) {
    switch (val) {
        
    case ConditionMarketType::COMMON:
        stream << static_cast<int32_t>(1);
        break;
        
    case ConditionMarketType::FIXING:
        stream << static_cast<int32_t>(2);
        break;
        
    case ConditionMarketType::ODD:
        stream << static_cast<int32_t>(3);
        break;
        
    case ConditionMarketType::INTRADAY_ODD:
        stream << static_cast<int32_t>(4);
        break;
        
    default:
        throw std::runtime_error("No matching ConditionMarketType variant");
    }
}

int32_t FfiConverterTypeConditionMarketType::allocation_size(const ConditionMarketType &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


ConditionOrderType FfiConverterTypeConditionOrderType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeConditionOrderType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeConditionOrderType::lower(const ConditionOrderType &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeConditionOrderType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeConditionOrderType::write(stream, val);

    return std::move(buf);
}

ConditionOrderType FfiConverterTypeConditionOrderType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return ConditionOrderType::STOCK;
        
    case 2:
        return ConditionOrderType::MARGIN;
        
    case 3:
        return ConditionOrderType::SHORT;
        
    case 4:
        return ConditionOrderType::DAY_TRADE;
        
    default:
        throw std::runtime_error("No matching ConditionOrderType variant");
    }
}

void FfiConverterTypeConditionOrderType::write(RustStream &stream, const ConditionOrderType &val) {
    switch (val) {
        
    case ConditionOrderType::STOCK:
        stream << static_cast<int32_t>(1);
        break;
        
    case ConditionOrderType::MARGIN:
        stream << static_cast<int32_t>(2);
        break;
        
    case ConditionOrderType::SHORT:
        stream << static_cast<int32_t>(3);
        break;
        
    case ConditionOrderType::DAY_TRADE:
        stream << static_cast<int32_t>(4);
        break;
        
    default:
        throw std::runtime_error("No matching ConditionOrderType variant");
    }
}

int32_t FfiConverterTypeConditionOrderType::allocation_size(const ConditionOrderType &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


ConditionPriceType FfiConverterTypeConditionPriceType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeConditionPriceType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeConditionPriceType::lower(const ConditionPriceType &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeConditionPriceType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeConditionPriceType::write(stream, val);

    return std::move(buf);
}

ConditionPriceType FfiConverterTypeConditionPriceType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return ConditionPriceType::LIMIT;
        
    case 2:
        return ConditionPriceType::MARKET;
        
    case 3:
        return ConditionPriceType::BID_PRICE;
        
    case 4:
        return ConditionPriceType::ASK_PRICE;
        
    case 5:
        return ConditionPriceType::MATCHED_PRICE;
        
    case 6:
        return ConditionPriceType::LIMIT_UP;
        
    case 7:
        return ConditionPriceType::LIMIT_DOWN;
        
    case 8:
        return ConditionPriceType::REFERENCE;
        
    default:
        throw std::runtime_error("No matching ConditionPriceType variant");
    }
}

void FfiConverterTypeConditionPriceType::write(RustStream &stream, const ConditionPriceType &val) {
    switch (val) {
        
    case ConditionPriceType::LIMIT:
        stream << static_cast<int32_t>(1);
        break;
        
    case ConditionPriceType::MARKET:
        stream << static_cast<int32_t>(2);
        break;
        
    case ConditionPriceType::BID_PRICE:
        stream << static_cast<int32_t>(3);
        break;
        
    case ConditionPriceType::ASK_PRICE:
        stream << static_cast<int32_t>(4);
        break;
        
    case ConditionPriceType::MATCHED_PRICE:
        stream << static_cast<int32_t>(5);
        break;
        
    case ConditionPriceType::LIMIT_UP:
        stream << static_cast<int32_t>(6);
        break;
        
    case ConditionPriceType::LIMIT_DOWN:
        stream << static_cast<int32_t>(7);
        break;
        
    case ConditionPriceType::REFERENCE:
        stream << static_cast<int32_t>(8);
        break;
        
    default:
        throw std::runtime_error("No matching ConditionPriceType variant");
    }
}

int32_t FfiConverterTypeConditionPriceType::allocation_size(const ConditionPriceType &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


ConditionStatus FfiConverterTypeConditionStatus::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeConditionStatus::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeConditionStatus::lower(const ConditionStatus &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeConditionStatus::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeConditionStatus::write(stream, val);

    return std::move(buf);
}

ConditionStatus FfiConverterTypeConditionStatus::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return ConditionStatus::TYPE1;
        
    case 2:
        return ConditionStatus::TYPE2;
        
    case 3:
        return ConditionStatus::TYPE3;
        
    case 4:
        return ConditionStatus::TYPE4;
        
    case 5:
        return ConditionStatus::TYPE5;
        
    case 6:
        return ConditionStatus::TYPE6;
        
    case 7:
        return ConditionStatus::TYPE7;
        
    case 8:
        return ConditionStatus::TYPE8;
        
    case 9:
        return ConditionStatus::TYPE9;
        
    case 10:
        return ConditionStatus::TYPE10;
        
    case 11:
        return ConditionStatus::TYPE11;
        
    default:
        throw std::runtime_error("No matching ConditionStatus variant");
    }
}

void FfiConverterTypeConditionStatus::write(RustStream &stream, const ConditionStatus &val) {
    switch (val) {
        
    case ConditionStatus::TYPE1:
        stream << static_cast<int32_t>(1);
        break;
        
    case ConditionStatus::TYPE2:
        stream << static_cast<int32_t>(2);
        break;
        
    case ConditionStatus::TYPE3:
        stream << static_cast<int32_t>(3);
        break;
        
    case ConditionStatus::TYPE4:
        stream << static_cast<int32_t>(4);
        break;
        
    case ConditionStatus::TYPE5:
        stream << static_cast<int32_t>(5);
        break;
        
    case ConditionStatus::TYPE6:
        stream << static_cast<int32_t>(6);
        break;
        
    case ConditionStatus::TYPE7:
        stream << static_cast<int32_t>(7);
        break;
        
    case ConditionStatus::TYPE8:
        stream << static_cast<int32_t>(8);
        break;
        
    case ConditionStatus::TYPE9:
        stream << static_cast<int32_t>(9);
        break;
        
    case ConditionStatus::TYPE10:
        stream << static_cast<int32_t>(10);
        break;
        
    case ConditionStatus::TYPE11:
        stream << static_cast<int32_t>(11);
        break;
        
    default:
        throw std::runtime_error("No matching ConditionStatus variant");
    }
}

int32_t FfiConverterTypeConditionStatus::allocation_size(const ConditionStatus &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


Direction FfiConverterTypeDirection::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeDirection::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeDirection::lower(const Direction &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeDirection::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeDirection::write(stream, val);

    return std::move(buf);
}

Direction FfiConverterTypeDirection::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return Direction::UP;
        
    case 2:
        return Direction::DOWN;
        
    default:
        throw std::runtime_error("No matching Direction variant");
    }
}

void FfiConverterTypeDirection::write(RustStream &stream, const Direction &val) {
    switch (val) {
        
    case Direction::UP:
        stream << static_cast<int32_t>(1);
        break;
        
    case Direction::DOWN:
        stream << static_cast<int32_t>(2);
        break;
        
    default:
        throw std::runtime_error("No matching Direction variant");
    }
}

int32_t FfiConverterTypeDirection::allocation_size(const Direction &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


std::unique_ptr<FubonError> FfiConverterTypeFubonError::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFubonError::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterTypeFubonError::lower(const FubonError &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFubonError::write(stream, val);

    return std::move(buf);
}

std::unique_ptr<FubonError> FfiConverterTypeFubonError::read(RustStream &stream) {
    int32_t v;
    stream >> v;

    switch (v) {
    case 1:
        return std::make_unique<fubon_error::AccountTypeError>(FfiConverterString::read(stream));
    
    case 2:
        return std::make_unique<fubon_error::ResponseError>(FfiConverterString::read(stream));
    
    case 3:
        return std::make_unique<fubon_error::LoginError2>(FfiConverterString::read(stream));
    
    case 4:
        return std::make_unique<fubon_error::LoginError>(FfiConverterString::read(stream));
    
    case 5:
        return std::make_unique<fubon_error::NotLoginError>(FfiConverterString::read(stream));
    
    case 6:
        return std::make_unique<fubon_error::CertError>(FfiConverterString::read(stream));
    
    case 7:
        return std::make_unique<fubon_error::OtherError>(FfiConverterString::read(stream));
    
    case 8:
        return std::make_unique<fubon_error::ConfigUrlError>(FfiConverterString::read(stream));
    
    case 9:
        return std::make_unique<fubon_error::TwoFactorLoginError>(FfiConverterString::read(stream));
    
    case 10:
        return std::make_unique<fubon_error::OrderCheckError>(FfiConverterString::read(stream));
    
    case 11:
        return std::make_unique<fubon_error::DmaError>(FfiConverterString::read(stream));
    
    case 12:
        return std::make_unique<fubon_error::ResponseProtocalError>(FfiConverterString::read(stream));
    
    case 13:
        return std::make_unique<fubon_error::NoDmaIpError>(FfiConverterString::read(stream));
    
    case 14:
        return std::make_unique<fubon_error::RealtimeError>(FfiConverterString::read(stream));
    
    case 15:
        return std::make_unique<fubon_error::MaintenanceDataFormatError>(FfiConverterString::read(stream));
    
    case 16:
        return std::make_unique<fubon_error::EmptyTargetResponseError>(FfiConverterString::read(stream));
    
    case 17:
        return std::make_unique<fubon_error::EmptyDataError>(FfiConverterString::read(stream));
    
    case 18:
        return std::make_unique<fubon_error::ResponseParseError>(FfiConverterString::read(stream));
    
    case 19:
        return std::make_unique<fubon_error::ResponseFormatError>(FfiConverterString::read(stream));
    
    case 20:
        return std::make_unique<fubon_error::NoTradeAccountError>(FfiConverterString::read(stream));
    
    case 21:
        return std::make_unique<fubon_error::CanNotModifyError>(FfiConverterString::read(stream));
    
    case 22:
        return std::make_unique<fubon_error::ContractError>(FfiConverterString::read(stream));
    
    default:
        throw std::runtime_error("Unexpected error variant");
    }
}

void FfiConverterTypeFubonError::write(RustStream &stream, const FubonError &val) {
    stream << val.get_variant_idx();
    FfiConverterString::write(stream, val.what());
}

int32_t FfiConverterTypeFubonError::allocation_size(const FubonError &val) {
    return static_cast<int32_t>(sizeof(int32_t));
}


FutOptConditionMarketType FfiConverterTypeFutOptConditionMarketType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFutOptConditionMarketType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFutOptConditionMarketType::lower(const FutOptConditionMarketType &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeFutOptConditionMarketType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFutOptConditionMarketType::write(stream, val);

    return std::move(buf);
}

FutOptConditionMarketType FfiConverterTypeFutOptConditionMarketType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return FutOptConditionMarketType::FUTURE;
        
    case 2:
        return FutOptConditionMarketType::OPTION;
        
    case 3:
        return FutOptConditionMarketType::FUTURE_NIGHT;
        
    case 4:
        return FutOptConditionMarketType::OPTION_NIGHT;
        
    default:
        throw std::runtime_error("No matching FutOptConditionMarketType variant");
    }
}

void FfiConverterTypeFutOptConditionMarketType::write(RustStream &stream, const FutOptConditionMarketType &val) {
    switch (val) {
        
    case FutOptConditionMarketType::FUTURE:
        stream << static_cast<int32_t>(1);
        break;
        
    case FutOptConditionMarketType::OPTION:
        stream << static_cast<int32_t>(2);
        break;
        
    case FutOptConditionMarketType::FUTURE_NIGHT:
        stream << static_cast<int32_t>(3);
        break;
        
    case FutOptConditionMarketType::OPTION_NIGHT:
        stream << static_cast<int32_t>(4);
        break;
        
    default:
        throw std::runtime_error("No matching FutOptConditionMarketType variant");
    }
}

int32_t FfiConverterTypeFutOptConditionMarketType::allocation_size(const FutOptConditionMarketType &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


FutOptConditionOrderType FfiConverterTypeFutOptConditionOrderType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFutOptConditionOrderType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFutOptConditionOrderType::lower(const FutOptConditionOrderType &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeFutOptConditionOrderType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFutOptConditionOrderType::write(stream, val);

    return std::move(buf);
}

FutOptConditionOrderType FfiConverterTypeFutOptConditionOrderType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return FutOptConditionOrderType::NEW;
        
    case 2:
        return FutOptConditionOrderType::CLOSE;
        
    default:
        throw std::runtime_error("No matching FutOptConditionOrderType variant");
    }
}

void FfiConverterTypeFutOptConditionOrderType::write(RustStream &stream, const FutOptConditionOrderType &val) {
    switch (val) {
        
    case FutOptConditionOrderType::NEW:
        stream << static_cast<int32_t>(1);
        break;
        
    case FutOptConditionOrderType::CLOSE:
        stream << static_cast<int32_t>(2);
        break;
        
    default:
        throw std::runtime_error("No matching FutOptConditionOrderType variant");
    }
}

int32_t FfiConverterTypeFutOptConditionOrderType::allocation_size(const FutOptConditionOrderType &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


FutOptConditionPriceType FfiConverterTypeFutOptConditionPriceType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFutOptConditionPriceType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFutOptConditionPriceType::lower(const FutOptConditionPriceType &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeFutOptConditionPriceType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFutOptConditionPriceType::write(stream, val);

    return std::move(buf);
}

FutOptConditionPriceType FfiConverterTypeFutOptConditionPriceType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return FutOptConditionPriceType::LIMIT;
        
    case 2:
        return FutOptConditionPriceType::MARKET;
        
    case 3:
        return FutOptConditionPriceType::BID_PRICE;
        
    case 4:
        return FutOptConditionPriceType::ASK_PRICE;
        
    case 5:
        return FutOptConditionPriceType::MATCHED_PRICE;
        
    case 6:
        return FutOptConditionPriceType::LIMIT_UP;
        
    case 7:
        return FutOptConditionPriceType::LIMIT_DOWN;
        
    case 8:
        return FutOptConditionPriceType::REFERENCE;
        
    case 9:
        return FutOptConditionPriceType::RANGE_MARKET;
        
    default:
        throw std::runtime_error("No matching FutOptConditionPriceType variant");
    }
}

void FfiConverterTypeFutOptConditionPriceType::write(RustStream &stream, const FutOptConditionPriceType &val) {
    switch (val) {
        
    case FutOptConditionPriceType::LIMIT:
        stream << static_cast<int32_t>(1);
        break;
        
    case FutOptConditionPriceType::MARKET:
        stream << static_cast<int32_t>(2);
        break;
        
    case FutOptConditionPriceType::BID_PRICE:
        stream << static_cast<int32_t>(3);
        break;
        
    case FutOptConditionPriceType::ASK_PRICE:
        stream << static_cast<int32_t>(4);
        break;
        
    case FutOptConditionPriceType::MATCHED_PRICE:
        stream << static_cast<int32_t>(5);
        break;
        
    case FutOptConditionPriceType::LIMIT_UP:
        stream << static_cast<int32_t>(6);
        break;
        
    case FutOptConditionPriceType::LIMIT_DOWN:
        stream << static_cast<int32_t>(7);
        break;
        
    case FutOptConditionPriceType::REFERENCE:
        stream << static_cast<int32_t>(8);
        break;
        
    case FutOptConditionPriceType::RANGE_MARKET:
        stream << static_cast<int32_t>(9);
        break;
        
    default:
        throw std::runtime_error("No matching FutOptConditionPriceType variant");
    }
}

int32_t FfiConverterTypeFutOptConditionPriceType::allocation_size(const FutOptConditionPriceType &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


FutOptMarketType FfiConverterTypeFutOptMarketType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFutOptMarketType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFutOptMarketType::lower(const FutOptMarketType &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeFutOptMarketType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFutOptMarketType::write(stream, val);

    return std::move(buf);
}

FutOptMarketType FfiConverterTypeFutOptMarketType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return FutOptMarketType::FUTURE;
        
    case 2:
        return FutOptMarketType::OPTION;
        
    case 3:
        return FutOptMarketType::FUTURE_NIGHT;
        
    case 4:
        return FutOptMarketType::OPTION_NIGHT;
        
    case 5:
        return FutOptMarketType::UN_SUPPORTED;
        
    case 6:
        return FutOptMarketType::UN_DEFINED;
        
    default:
        throw std::runtime_error("No matching FutOptMarketType variant");
    }
}

void FfiConverterTypeFutOptMarketType::write(RustStream &stream, const FutOptMarketType &val) {
    switch (val) {
        
    case FutOptMarketType::FUTURE:
        stream << static_cast<int32_t>(1);
        break;
        
    case FutOptMarketType::OPTION:
        stream << static_cast<int32_t>(2);
        break;
        
    case FutOptMarketType::FUTURE_NIGHT:
        stream << static_cast<int32_t>(3);
        break;
        
    case FutOptMarketType::OPTION_NIGHT:
        stream << static_cast<int32_t>(4);
        break;
        
    case FutOptMarketType::UN_SUPPORTED:
        stream << static_cast<int32_t>(5);
        break;
        
    case FutOptMarketType::UN_DEFINED:
        stream << static_cast<int32_t>(6);
        break;
        
    default:
        throw std::runtime_error("No matching FutOptMarketType variant");
    }
}

int32_t FfiConverterTypeFutOptMarketType::allocation_size(const FutOptMarketType &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


FutOptOrderType FfiConverterTypeFutOptOrderType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFutOptOrderType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFutOptOrderType::lower(const FutOptOrderType &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeFutOptOrderType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFutOptOrderType::write(stream, val);

    return std::move(buf);
}

FutOptOrderType FfiConverterTypeFutOptOrderType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return FutOptOrderType::NEW;
        
    case 2:
        return FutOptOrderType::CLOSE;
        
    case 3:
        return FutOptOrderType::AUTO;
        
    case 4:
        return FutOptOrderType::FDAY_TRADE;
        
    case 5:
        return FutOptOrderType::UN_SUPPORTED;
        
    case 6:
        return FutOptOrderType::UN_DEFINED;
        
    default:
        throw std::runtime_error("No matching FutOptOrderType variant");
    }
}

void FfiConverterTypeFutOptOrderType::write(RustStream &stream, const FutOptOrderType &val) {
    switch (val) {
        
    case FutOptOrderType::NEW:
        stream << static_cast<int32_t>(1);
        break;
        
    case FutOptOrderType::CLOSE:
        stream << static_cast<int32_t>(2);
        break;
        
    case FutOptOrderType::AUTO:
        stream << static_cast<int32_t>(3);
        break;
        
    case FutOptOrderType::FDAY_TRADE:
        stream << static_cast<int32_t>(4);
        break;
        
    case FutOptOrderType::UN_SUPPORTED:
        stream << static_cast<int32_t>(5);
        break;
        
    case FutOptOrderType::UN_DEFINED:
        stream << static_cast<int32_t>(6);
        break;
        
    default:
        throw std::runtime_error("No matching FutOptOrderType variant");
    }
}

int32_t FfiConverterTypeFutOptOrderType::allocation_size(const FutOptOrderType &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


FutOptPriceType FfiConverterTypeFutOptPriceType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeFutOptPriceType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeFutOptPriceType::lower(const FutOptPriceType &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeFutOptPriceType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeFutOptPriceType::write(stream, val);

    return std::move(buf);
}

FutOptPriceType FfiConverterTypeFutOptPriceType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return FutOptPriceType::LIMIT;
        
    case 2:
        return FutOptPriceType::MARKET;
        
    case 3:
        return FutOptPriceType::RANGE_MARKET;
        
    case 4:
        return FutOptPriceType::REFERENCE;
        
    case 5:
        return FutOptPriceType::UN_SUPPORTED;
        
    case 6:
        return FutOptPriceType::UN_DEFINED;
        
    default:
        throw std::runtime_error("No matching FutOptPriceType variant");
    }
}

void FfiConverterTypeFutOptPriceType::write(RustStream &stream, const FutOptPriceType &val) {
    switch (val) {
        
    case FutOptPriceType::LIMIT:
        stream << static_cast<int32_t>(1);
        break;
        
    case FutOptPriceType::MARKET:
        stream << static_cast<int32_t>(2);
        break;
        
    case FutOptPriceType::RANGE_MARKET:
        stream << static_cast<int32_t>(3);
        break;
        
    case FutOptPriceType::REFERENCE:
        stream << static_cast<int32_t>(4);
        break;
        
    case FutOptPriceType::UN_SUPPORTED:
        stream << static_cast<int32_t>(5);
        break;
        
    case FutOptPriceType::UN_DEFINED:
        stream << static_cast<int32_t>(6);
        break;
        
    default:
        throw std::runtime_error("No matching FutOptPriceType variant");
    }
}

int32_t FfiConverterTypeFutOptPriceType::allocation_size(const FutOptPriceType &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


HistoryStatus FfiConverterTypeHistoryStatus::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeHistoryStatus::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeHistoryStatus::lower(const HistoryStatus &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeHistoryStatus::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeHistoryStatus::write(stream, val);

    return std::move(buf);
}

HistoryStatus FfiConverterTypeHistoryStatus::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return HistoryStatus::TYPE1;
        
    case 2:
        return HistoryStatus::TYPE2;
        
    case 3:
        return HistoryStatus::TYPE3;
        
    case 4:
        return HistoryStatus::TYPE4;
        
    case 5:
        return HistoryStatus::TYPE5;
        
    case 6:
        return HistoryStatus::TYPE6;
        
    default:
        throw std::runtime_error("No matching HistoryStatus variant");
    }
}

void FfiConverterTypeHistoryStatus::write(RustStream &stream, const HistoryStatus &val) {
    switch (val) {
        
    case HistoryStatus::TYPE1:
        stream << static_cast<int32_t>(1);
        break;
        
    case HistoryStatus::TYPE2:
        stream << static_cast<int32_t>(2);
        break;
        
    case HistoryStatus::TYPE3:
        stream << static_cast<int32_t>(3);
        break;
        
    case HistoryStatus::TYPE4:
        stream << static_cast<int32_t>(4);
        break;
        
    case HistoryStatus::TYPE5:
        stream << static_cast<int32_t>(5);
        break;
        
    case HistoryStatus::TYPE6:
        stream << static_cast<int32_t>(6);
        break;
        
    default:
        throw std::runtime_error("No matching HistoryStatus variant");
    }
}

int32_t FfiConverterTypeHistoryStatus::allocation_size(const HistoryStatus &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


MarketType FfiConverterTypeMarketType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeMarketType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeMarketType::lower(const MarketType &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeMarketType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeMarketType::write(stream, val);

    return std::move(buf);
}

MarketType FfiConverterTypeMarketType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return MarketType::COMMON;
        
    case 2:
        return MarketType::FIXING;
        
    case 3:
        return MarketType::ODD;
        
    case 4:
        return MarketType::INTRADAY_ODD;
        
    case 5:
        return MarketType::EMG;
        
    case 6:
        return MarketType::EMG_ODD;
        
    case 7:
        return MarketType::UN_SUPPORTED;
        
    case 8:
        return MarketType::UN_DEFINED;
        
    default:
        throw std::runtime_error("No matching MarketType variant");
    }
}

void FfiConverterTypeMarketType::write(RustStream &stream, const MarketType &val) {
    switch (val) {
        
    case MarketType::COMMON:
        stream << static_cast<int32_t>(1);
        break;
        
    case MarketType::FIXING:
        stream << static_cast<int32_t>(2);
        break;
        
    case MarketType::ODD:
        stream << static_cast<int32_t>(3);
        break;
        
    case MarketType::INTRADAY_ODD:
        stream << static_cast<int32_t>(4);
        break;
        
    case MarketType::EMG:
        stream << static_cast<int32_t>(5);
        break;
        
    case MarketType::EMG_ODD:
        stream << static_cast<int32_t>(6);
        break;
        
    case MarketType::UN_SUPPORTED:
        stream << static_cast<int32_t>(7);
        break;
        
    case MarketType::UN_DEFINED:
        stream << static_cast<int32_t>(8);
        break;
        
    default:
        throw std::runtime_error("No matching MarketType variant");
    }
}

int32_t FfiConverterTypeMarketType::allocation_size(const MarketType &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


Operator FfiConverterTypeOperator::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeOperator::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeOperator::lower(const Operator &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeOperator::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeOperator::write(stream, val);

    return std::move(buf);
}

Operator FfiConverterTypeOperator::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return Operator::GREATER_THAN_OR_EQUAL;
        
    case 2:
        return Operator::LESS_THAN_OR_EQUAL;
        
    case 3:
        return Operator::GREATER_THAN;
        
    case 4:
        return Operator::LESS_THAN;
        
    default:
        throw std::runtime_error("No matching Operator variant");
    }
}

void FfiConverterTypeOperator::write(RustStream &stream, const Operator &val) {
    switch (val) {
        
    case Operator::GREATER_THAN_OR_EQUAL:
        stream << static_cast<int32_t>(1);
        break;
        
    case Operator::LESS_THAN_OR_EQUAL:
        stream << static_cast<int32_t>(2);
        break;
        
    case Operator::GREATER_THAN:
        stream << static_cast<int32_t>(3);
        break;
        
    case Operator::LESS_THAN:
        stream << static_cast<int32_t>(4);
        break;
        
    default:
        throw std::runtime_error("No matching Operator variant");
    }
}

int32_t FfiConverterTypeOperator::allocation_size(const Operator &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


OrderType FfiConverterTypeOrderType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeOrderType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeOrderType::lower(const OrderType &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeOrderType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeOrderType::write(stream, val);

    return std::move(buf);
}

OrderType FfiConverterTypeOrderType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return OrderType::STOCK;
        
    case 2:
        return OrderType::MARGIN;
        
    case 3:
        return OrderType::SHORT;
        
    case 4:
        return OrderType::SBL;
        
    case 5:
        return OrderType::DAY_TRADE;
        
    case 6:
        return OrderType::UN_SUPPORTED;
        
    case 7:
        return OrderType::UN_DEFINED;
        
    default:
        throw std::runtime_error("No matching OrderType variant");
    }
}

void FfiConverterTypeOrderType::write(RustStream &stream, const OrderType &val) {
    switch (val) {
        
    case OrderType::STOCK:
        stream << static_cast<int32_t>(1);
        break;
        
    case OrderType::MARGIN:
        stream << static_cast<int32_t>(2);
        break;
        
    case OrderType::SHORT:
        stream << static_cast<int32_t>(3);
        break;
        
    case OrderType::SBL:
        stream << static_cast<int32_t>(4);
        break;
        
    case OrderType::DAY_TRADE:
        stream << static_cast<int32_t>(5);
        break;
        
    case OrderType::UN_SUPPORTED:
        stream << static_cast<int32_t>(6);
        break;
        
    case OrderType::UN_DEFINED:
        stream << static_cast<int32_t>(7);
        break;
        
    default:
        throw std::runtime_error("No matching OrderType variant");
    }
}

int32_t FfiConverterTypeOrderType::allocation_size(const OrderType &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


PriceType FfiConverterTypePriceType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePriceType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePriceType::lower(const PriceType &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypePriceType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePriceType::write(stream, val);

    return std::move(buf);
}

PriceType FfiConverterTypePriceType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return PriceType::LIMIT;
        
    case 2:
        return PriceType::MARKET;
        
    case 3:
        return PriceType::LIMIT_UP;
        
    case 4:
        return PriceType::LIMIT_DOWN;
        
    case 5:
        return PriceType::REFERENCE;
        
    case 6:
        return PriceType::UN_SUPPORTED;
        
    case 7:
        return PriceType::UN_DEFINED;
        
    default:
        throw std::runtime_error("No matching PriceType variant");
    }
}

void FfiConverterTypePriceType::write(RustStream &stream, const PriceType &val) {
    switch (val) {
        
    case PriceType::LIMIT:
        stream << static_cast<int32_t>(1);
        break;
        
    case PriceType::MARKET:
        stream << static_cast<int32_t>(2);
        break;
        
    case PriceType::LIMIT_UP:
        stream << static_cast<int32_t>(3);
        break;
        
    case PriceType::LIMIT_DOWN:
        stream << static_cast<int32_t>(4);
        break;
        
    case PriceType::REFERENCE:
        stream << static_cast<int32_t>(5);
        break;
        
    case PriceType::UN_SUPPORTED:
        stream << static_cast<int32_t>(6);
        break;
        
    case PriceType::UN_DEFINED:
        stream << static_cast<int32_t>(7);
        break;
        
    default:
        throw std::runtime_error("No matching PriceType variant");
    }
}

int32_t FfiConverterTypePriceType::allocation_size(const PriceType &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


StockType FfiConverterTypeStockType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeStockType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeStockType::lower(const StockType &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeStockType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeStockType::write(stream, val);

    return std::move(buf);
}

StockType FfiConverterTypeStockType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return StockType::STOCK;
        
    case 2:
        return StockType::COVERT_BOND;
        
    case 3:
        return StockType::ETF_AND_ETN;
        
    default:
        throw std::runtime_error("No matching StockType variant");
    }
}

void FfiConverterTypeStockType::write(RustStream &stream, const StockType &val) {
    switch (val) {
        
    case StockType::STOCK:
        stream << static_cast<int32_t>(1);
        break;
        
    case StockType::COVERT_BOND:
        stream << static_cast<int32_t>(2);
        break;
        
    case StockType::ETF_AND_ETN:
        stream << static_cast<int32_t>(3);
        break;
        
    default:
        throw std::runtime_error("No matching StockType variant");
    }
}

int32_t FfiConverterTypeStockType::allocation_size(const StockType &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


StopSign FfiConverterTypeStopSign::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeStopSign::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeStopSign::lower(const StopSign &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeStopSign::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeStopSign::write(stream, val);

    return std::move(buf);
}

StopSign FfiConverterTypeStopSign::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return StopSign::FULL;
        
    case 2:
        return StopSign::PARTIAL;
        
    case 3:
        return StopSign::UNTIL_END;
        
    default:
        throw std::runtime_error("No matching StopSign variant");
    }
}

void FfiConverterTypeStopSign::write(RustStream &stream, const StopSign &val) {
    switch (val) {
        
    case StopSign::FULL:
        stream << static_cast<int32_t>(1);
        break;
        
    case StopSign::PARTIAL:
        stream << static_cast<int32_t>(2);
        break;
        
    case StopSign::UNTIL_END:
        stream << static_cast<int32_t>(3);
        break;
        
    default:
        throw std::runtime_error("No matching StopSign variant");
    }
}

int32_t FfiConverterTypeStopSign::allocation_size(const StopSign &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


TimeInForce FfiConverterTypeTimeInForce::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTimeInForce::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTimeInForce::lower(const TimeInForce &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeTimeInForce::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTimeInForce::write(stream, val);

    return std::move(buf);
}

TimeInForce FfiConverterTypeTimeInForce::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return TimeInForce::ROD;
        
    case 2:
        return TimeInForce::FOK;
        
    case 3:
        return TimeInForce::IOC;
        
    case 4:
        return TimeInForce::UN_SUPPORTED;
        
    case 5:
        return TimeInForce::UN_DEFINED;
        
    default:
        throw std::runtime_error("No matching TimeInForce variant");
    }
}

void FfiConverterTypeTimeInForce::write(RustStream &stream, const TimeInForce &val) {
    switch (val) {
        
    case TimeInForce::ROD:
        stream << static_cast<int32_t>(1);
        break;
        
    case TimeInForce::FOK:
        stream << static_cast<int32_t>(2);
        break;
        
    case TimeInForce::IOC:
        stream << static_cast<int32_t>(3);
        break;
        
    case TimeInForce::UN_SUPPORTED:
        stream << static_cast<int32_t>(4);
        break;
        
    case TimeInForce::UN_DEFINED:
        stream << static_cast<int32_t>(5);
        break;
        
    default:
        throw std::runtime_error("No matching TimeInForce variant");
    }
}

int32_t FfiConverterTypeTimeInForce::allocation_size(const TimeInForce &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


TimeSliceOrderType FfiConverterTypeTimeSliceOrderType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTimeSliceOrderType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTimeSliceOrderType::lower(const TimeSliceOrderType &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeTimeSliceOrderType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTimeSliceOrderType::write(stream, val);

    return std::move(buf);
}

TimeSliceOrderType FfiConverterTypeTimeSliceOrderType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return TimeSliceOrderType::TYPE1;
        
    case 2:
        return TimeSliceOrderType::TYPE2;
        
    case 3:
        return TimeSliceOrderType::TYPE3;
        
    case 4:
        return TimeSliceOrderType::TYPE4;
        
    case 5:
        return TimeSliceOrderType::TYPE5;
        
    case 6:
        return TimeSliceOrderType::TYPE6;
        
    case 7:
        return TimeSliceOrderType::TYPE7;
        
    default:
        throw std::runtime_error("No matching TimeSliceOrderType variant");
    }
}

void FfiConverterTypeTimeSliceOrderType::write(RustStream &stream, const TimeSliceOrderType &val) {
    switch (val) {
        
    case TimeSliceOrderType::TYPE1:
        stream << static_cast<int32_t>(1);
        break;
        
    case TimeSliceOrderType::TYPE2:
        stream << static_cast<int32_t>(2);
        break;
        
    case TimeSliceOrderType::TYPE3:
        stream << static_cast<int32_t>(3);
        break;
        
    case TimeSliceOrderType::TYPE4:
        stream << static_cast<int32_t>(4);
        break;
        
    case TimeSliceOrderType::TYPE5:
        stream << static_cast<int32_t>(5);
        break;
        
    case TimeSliceOrderType::TYPE6:
        stream << static_cast<int32_t>(6);
        break;
        
    case TimeSliceOrderType::TYPE7:
        stream << static_cast<int32_t>(7);
        break;
        
    default:
        throw std::runtime_error("No matching TimeSliceOrderType variant");
    }
}

int32_t FfiConverterTypeTimeSliceOrderType::allocation_size(const TimeSliceOrderType &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


TradingType FfiConverterTypeTradingType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTradingType::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTradingType::lower(const TradingType &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeTradingType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTradingType::write(stream, val);

    return std::move(buf);
}

TradingType FfiConverterTypeTradingType::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return TradingType::REFERENCE;
        
    case 2:
        return TradingType::INDEX;
        
    case 3:
        return TradingType::SCHEDULED;
        
    default:
        throw std::runtime_error("No matching TradingType variant");
    }
}

void FfiConverterTypeTradingType::write(RustStream &stream, const TradingType &val) {
    switch (val) {
        
    case TradingType::REFERENCE:
        stream << static_cast<int32_t>(1);
        break;
        
    case TradingType::INDEX:
        stream << static_cast<int32_t>(2);
        break;
        
    case TradingType::SCHEDULED:
        stream << static_cast<int32_t>(3);
        break;
        
    default:
        throw std::runtime_error("No matching TradingType variant");
    }
}

int32_t FfiConverterTypeTradingType::allocation_size(const TradingType &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


TriggerContent FfiConverterTypeTriggerContent::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeTriggerContent::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeTriggerContent::lower(const TriggerContent &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeTriggerContent::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeTriggerContent::write(stream, val);

    return std::move(buf);
}

TriggerContent FfiConverterTypeTriggerContent::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {
        
    case 1:
        return TriggerContent::BID_PRICE;
        
    case 2:
        return TriggerContent::ASK_PRICE;
        
    case 3:
        return TriggerContent::MATCHED_PRICE;
        
    case 4:
        return TriggerContent::TOTAL_QUANTITY;
        
    case 5:
        return TriggerContent::TIME;
        
    case 6:
        return TriggerContent::TOTAL_VALUE;
        
    default:
        throw std::runtime_error("No matching TriggerContent variant");
    }
}

void FfiConverterTypeTriggerContent::write(RustStream &stream, const TriggerContent &val) {
    switch (val) {
        
    case TriggerContent::BID_PRICE:
        stream << static_cast<int32_t>(1);
        break;
        
    case TriggerContent::ASK_PRICE:
        stream << static_cast<int32_t>(2);
        break;
        
    case TriggerContent::MATCHED_PRICE:
        stream << static_cast<int32_t>(3);
        break;
        
    case TriggerContent::TOTAL_QUANTITY:
        stream << static_cast<int32_t>(4);
        break;
        
    case TriggerContent::TIME:
        stream << static_cast<int32_t>(5);
        break;
        
    case TriggerContent::TOTAL_VALUE:
        stream << static_cast<int32_t>(6);
        break;
        
    default:
        throw std::runtime_error("No matching TriggerContent variant");
    }
}

int32_t FfiConverterTypeTriggerContent::allocation_size(const TriggerContent &) {
    return static_cast<int32_t>(sizeof(int32_t));
}


std::once_flag FfiConverterCallback::once = std::once_flag();
uniffi::HandleMap<Callback> FfiConverterCallback::callbacks = {};

std::shared_ptr<Callback> FfiConverterCallback::lift(uint64_t handle) {
    std::call_once(FfiConverterCallback::once, []() {
        rust_call(uniffi_fubon_fn_init_callback_callback, nullptr, callback_stub);
    });

    return callbacks.at(handle);
}

uint64_t FfiConverterCallback::lower(const std::shared_ptr<Callback>& impl) {
    std::call_once(FfiConverterCallback::once, []() {
        rust_call(uniffi_fubon_fn_init_callback_callback, nullptr, callback_stub);
    });

    return callbacks.insert(impl);
}

std::shared_ptr<Callback> uniffi::FfiConverterCallback::read(RustStream &stream) {
    uint64_t handle;
    stream >> handle;

    return lift(handle);
}

void uniffi::FfiConverterCallback::write(RustStream &stream, const std::shared_ptr<Callback> &impl) {
    stream << lower(impl);
}

int32_t uniffi::FfiConverterCallback::allocation_size(const std::shared_ptr<Callback> &impl) {
    return static_cast<int32_t>(sizeof(uint64_t));
}

int FfiConverterCallback::callback_stub(uint64_t handle, uint32_t method, uint8_t *args_data, int32_t args_len, RustBuffer *buf_ptr) {
    auto buf = RustBuffer {
        .capacity = args_len,
        .len = args_len,
        .data = args_data,
    };
    auto stream = RustStream(&buf);

    switch (method) {
    case 0:
        callbacks.erase(handle);
        break;
    case 1: {
        
            auto impl = lift(handle);
            auto arg0 =FfiConverterOptionalString::read(stream);
            auto arg1 =FfiConverterTypeOrderResult::read(stream);impl->on_order(
            std::move(arg0), 
            std::move(arg1));
        break;
    }
    case 2: {
        
            auto impl = lift(handle);
            auto arg0 =FfiConverterOptionalString::read(stream);
            auto arg1 =FfiConverterTypeOrderResult::read(stream);impl->on_order_changed(
            std::move(arg0), 
            std::move(arg1));
        break;
    }
    case 3: {
        
            auto impl = lift(handle);
            auto arg0 =FfiConverterOptionalString::read(stream);
            auto arg1 =FfiConverterTypeFilledData::read(stream);impl->on_filled(
            std::move(arg0), 
            std::move(arg1));
        break;
    }
    case 4: {
        
            auto impl = lift(handle);
            auto arg0 =FfiConverterOptionalString::read(stream);
            auto arg1 =FfiConverterTypeFutOptOrderResult::read(stream);impl->on_futopt_order(
            std::move(arg0), 
            std::move(arg1));
        break;
    }
    case 5: {
        
            auto impl = lift(handle);
            auto arg0 =FfiConverterOptionalString::read(stream);
            auto arg1 =FfiConverterTypeFutOptOrderResult::read(stream);impl->on_futopt_order_changed(
            std::move(arg0), 
            std::move(arg1));
        break;
    }
    case 6: {
        
            auto impl = lift(handle);
            auto arg0 =FfiConverterOptionalString::read(stream);
            auto arg1 =FfiConverterTypeFutOptFilledData::read(stream);impl->on_futopt_filled(
            std::move(arg0), 
            std::move(arg1));
        break;
    }
    case 7: {
        
            auto impl = lift(handle);
            auto arg0 =FfiConverterString::read(stream);
            auto arg1 =FfiConverterString::read(stream);impl->on_event(
            std::move(arg0), 
            std::move(arg1));
        break;
    }
    }

    return 0;
}

std::optional<int32_t> FfiConverterOptionalInt32::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalInt32::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalInt32::lower(const std::optional<int32_t>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalInt32::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalInt32::write(stream, val);

    return buf;
}

std::optional<int32_t> FfiConverterOptionalInt32::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterInt32::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalInt32::write(RustStream &stream, const std::optional<int32_t>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterInt32::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalInt32::allocation_size(const std::optional<int32_t> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterInt32::allocation_size(val.value());
    }

    return ret;
}

std::optional<uint64_t> FfiConverterOptionalUInt64::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalUInt64::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalUInt64::lower(const std::optional<uint64_t>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalUInt64::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalUInt64::write(stream, val);

    return buf;
}

std::optional<uint64_t> FfiConverterOptionalUInt64::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterUInt64::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalUInt64::write(RustStream &stream, const std::optional<uint64_t>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterUInt64::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalUInt64::allocation_size(const std::optional<uint64_t> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterUInt64::allocation_size(val.value());
    }

    return ret;
}

std::optional<int64_t> FfiConverterOptionalInt64::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalInt64::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalInt64::lower(const std::optional<int64_t>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalInt64::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalInt64::write(stream, val);

    return buf;
}

std::optional<int64_t> FfiConverterOptionalInt64::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterInt64::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalInt64::write(RustStream &stream, const std::optional<int64_t>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterInt64::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalInt64::allocation_size(const std::optional<int64_t> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterInt64::allocation_size(val.value());
    }

    return ret;
}

std::optional<double> FfiConverterOptionalDouble::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalDouble::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalDouble::lower(const std::optional<double>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalDouble::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalDouble::write(stream, val);

    return buf;
}

std::optional<double> FfiConverterOptionalDouble::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterDouble::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalDouble::write(RustStream &stream, const std::optional<double>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterDouble::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalDouble::allocation_size(const std::optional<double> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterDouble::allocation_size(val.value());
    }

    return ret;
}

std::optional<bool> FfiConverterOptionalBool::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalBool::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalBool::lower(const std::optional<bool>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalBool::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalBool::write(stream, val);

    return buf;
}

std::optional<bool> FfiConverterOptionalBool::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterBool::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalBool::write(RustStream &stream, const std::optional<bool>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterBool::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalBool::allocation_size(const std::optional<bool> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterBool::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::string> FfiConverterOptionalString::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalString::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalString::lower(const std::optional<std::string>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalString::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalString::write(stream, val);

    return buf;
}

std::optional<std::string> FfiConverterOptionalString::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterString::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalString::write(RustStream &stream, const std::optional<std::string>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterString::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalString::allocation_size(const std::optional<std::string> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterString::allocation_size(val.value());
    }

    return ret;
}

std::optional<BankRemain> FfiConverterOptionalTypeBankRemain::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeBankRemain::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeBankRemain::lower(const std::optional<BankRemain>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeBankRemain::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeBankRemain::write(stream, val);

    return buf;
}

std::optional<BankRemain> FfiConverterOptionalTypeBankRemain::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeBankRemain::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeBankRemain::write(RustStream &stream, const std::optional<BankRemain>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeBankRemain::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeBankRemain::allocation_size(const std::optional<BankRemain> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeBankRemain::allocation_size(val.value());
    }

    return ret;
}

std::optional<ConditionOrderResult> FfiConverterOptionalTypeConditionOrderResult::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeConditionOrderResult::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeConditionOrderResult::lower(const std::optional<ConditionOrderResult>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeConditionOrderResult::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeConditionOrderResult::write(stream, val);

    return buf;
}

std::optional<ConditionOrderResult> FfiConverterOptionalTypeConditionOrderResult::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeConditionOrderResult::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeConditionOrderResult::write(RustStream &stream, const std::optional<ConditionOrderResult>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeConditionOrderResult::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeConditionOrderResult::allocation_size(const std::optional<ConditionOrderResult> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeConditionOrderResult::allocation_size(val.value());
    }

    return ret;
}

std::optional<DayTradeStockInfo> FfiConverterOptionalTypeDayTradeStockInfo::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeDayTradeStockInfo::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeDayTradeStockInfo::lower(const std::optional<DayTradeStockInfo>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeDayTradeStockInfo::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeDayTradeStockInfo::write(stream, val);

    return buf;
}

std::optional<DayTradeStockInfo> FfiConverterOptionalTypeDayTradeStockInfo::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeDayTradeStockInfo::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeDayTradeStockInfo::write(RustStream &stream, const std::optional<DayTradeStockInfo>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeDayTradeStockInfo::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeDayTradeStockInfo::allocation_size(const std::optional<DayTradeStockInfo> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeDayTradeStockInfo::allocation_size(val.value());
    }

    return ret;
}

std::optional<EstimateMargin> FfiConverterOptionalTypeEstimateMargin::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeEstimateMargin::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeEstimateMargin::lower(const std::optional<EstimateMargin>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeEstimateMargin::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeEstimateMargin::write(stream, val);

    return buf;
}

std::optional<EstimateMargin> FfiConverterOptionalTypeEstimateMargin::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeEstimateMargin::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeEstimateMargin::write(RustStream &stream, const std::optional<EstimateMargin>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeEstimateMargin::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeEstimateMargin::allocation_size(const std::optional<EstimateMargin> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeEstimateMargin::allocation_size(val.value());
    }

    return ret;
}

std::optional<FutOptOrderResult> FfiConverterOptionalTypeFutOptOrderResult::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeFutOptOrderResult::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeFutOptOrderResult::lower(const std::optional<FutOptOrderResult>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeFutOptOrderResult::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeFutOptOrderResult::write(stream, val);

    return buf;
}

std::optional<FutOptOrderResult> FfiConverterOptionalTypeFutOptOrderResult::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeFutOptOrderResult::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeFutOptOrderResult::write(RustStream &stream, const std::optional<FutOptOrderResult>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeFutOptOrderResult::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeFutOptOrderResult::allocation_size(const std::optional<FutOptOrderResult> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeFutOptOrderResult::allocation_size(val.value());
    }

    return ret;
}

std::optional<FutOptTpslOrder> FfiConverterOptionalTypeFutOptTPSLOrder::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeFutOptTPSLOrder::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeFutOptTPSLOrder::lower(const std::optional<FutOptTpslOrder>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeFutOptTPSLOrder::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeFutOptTPSLOrder::write(stream, val);

    return buf;
}

std::optional<FutOptTpslOrder> FfiConverterOptionalTypeFutOptTPSLOrder::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeFutOptTPSLOrder::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeFutOptTPSLOrder::write(RustStream &stream, const std::optional<FutOptTpslOrder>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeFutOptTPSLOrder::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeFutOptTPSLOrder::allocation_size(const std::optional<FutOptTpslOrder> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeFutOptTPSLOrder::allocation_size(val.value());
    }

    return ret;
}

std::optional<FutOptTPSLWrapper> FfiConverterOptionalTypeFutOptTPSLWrapper::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeFutOptTPSLWrapper::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeFutOptTPSLWrapper::lower(const std::optional<FutOptTPSLWrapper>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeFutOptTPSLWrapper::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeFutOptTPSLWrapper::write(stream, val);

    return buf;
}

std::optional<FutOptTPSLWrapper> FfiConverterOptionalTypeFutOptTPSLWrapper::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeFutOptTPSLWrapper::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeFutOptTPSLWrapper::write(RustStream &stream, const std::optional<FutOptTPSLWrapper>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeFutOptTPSLWrapper::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeFutOptTPSLWrapper::allocation_size(const std::optional<FutOptTPSLWrapper> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeFutOptTPSLWrapper::allocation_size(val.value());
    }

    return ret;
}

std::optional<MaintenanceData> FfiConverterOptionalTypeMaintenanceData::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeMaintenanceData::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeMaintenanceData::lower(const std::optional<MaintenanceData>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeMaintenanceData::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeMaintenanceData::write(stream, val);

    return buf;
}

std::optional<MaintenanceData> FfiConverterOptionalTypeMaintenanceData::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeMaintenanceData::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeMaintenanceData::write(RustStream &stream, const std::optional<MaintenanceData>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeMaintenanceData::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeMaintenanceData::allocation_size(const std::optional<MaintenanceData> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeMaintenanceData::allocation_size(val.value());
    }

    return ret;
}

std::optional<MarginShortQuota> FfiConverterOptionalTypeMarginShortQuota::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeMarginShortQuota::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeMarginShortQuota::lower(const std::optional<MarginShortQuota>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeMarginShortQuota::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeMarginShortQuota::write(stream, val);

    return buf;
}

std::optional<MarginShortQuota> FfiConverterOptionalTypeMarginShortQuota::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeMarginShortQuota::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeMarginShortQuota::write(RustStream &stream, const std::optional<MarginShortQuota>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeMarginShortQuota::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeMarginShortQuota::allocation_size(const std::optional<MarginShortQuota> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeMarginShortQuota::allocation_size(val.value());
    }

    return ret;
}

std::optional<OrderResult> FfiConverterOptionalTypeOrderResult::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeOrderResult::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeOrderResult::lower(const std::optional<OrderResult>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeOrderResult::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeOrderResult::write(stream, val);

    return buf;
}

std::optional<OrderResult> FfiConverterOptionalTypeOrderResult::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeOrderResult::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeOrderResult::write(RustStream &stream, const std::optional<OrderResult>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeOrderResult::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeOrderResult::allocation_size(const std::optional<OrderResult> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeOrderResult::allocation_size(val.value());
    }

    return ret;
}

std::optional<SettlementData> FfiConverterOptionalTypeSettlementData::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeSettlementData::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeSettlementData::lower(const std::optional<SettlementData>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeSettlementData::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeSettlementData::write(stream, val);

    return buf;
}

std::optional<SettlementData> FfiConverterOptionalTypeSettlementData::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeSettlementData::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeSettlementData::write(RustStream &stream, const std::optional<SettlementData>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeSettlementData::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeSettlementData::allocation_size(const std::optional<SettlementData> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeSettlementData::allocation_size(val.value());
    }

    return ret;
}

std::optional<SymbolQuote> FfiConverterOptionalTypeSymbolQuote::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeSymbolQuote::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeSymbolQuote::lower(const std::optional<SymbolQuote>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeSymbolQuote::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeSymbolQuote::write(stream, val);

    return buf;
}

std::optional<SymbolQuote> FfiConverterOptionalTypeSymbolQuote::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeSymbolQuote::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeSymbolQuote::write(RustStream &stream, const std::optional<SymbolQuote>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeSymbolQuote::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeSymbolQuote::allocation_size(const std::optional<SymbolQuote> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeSymbolQuote::allocation_size(val.value());
    }

    return ret;
}

std::optional<TpslOrder> FfiConverterOptionalTypeTPSLOrder::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeTPSLOrder::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeTPSLOrder::lower(const std::optional<TpslOrder>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeTPSLOrder::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeTPSLOrder::write(stream, val);

    return buf;
}

std::optional<TpslOrder> FfiConverterOptionalTypeTPSLOrder::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeTPSLOrder::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeTPSLOrder::write(RustStream &stream, const std::optional<TpslOrder>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeTPSLOrder::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeTPSLOrder::allocation_size(const std::optional<TpslOrder> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeTPSLOrder::allocation_size(val.value());
    }

    return ret;
}

std::optional<TPSLWrapper> FfiConverterOptionalTypeTPSLWrapper::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeTPSLWrapper::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeTPSLWrapper::lower(const std::optional<TPSLWrapper>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeTPSLWrapper::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeTPSLWrapper::write(stream, val);

    return buf;
}

std::optional<TPSLWrapper> FfiConverterOptionalTypeTPSLWrapper::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeTPSLWrapper::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeTPSLWrapper::write(RustStream &stream, const std::optional<TPSLWrapper>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeTPSLWrapper::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeTPSLWrapper::allocation_size(const std::optional<TPSLWrapper> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeTPSLWrapper::allocation_size(val.value());
    }

    return ret;
}

std::optional<BsAction> FfiConverterOptionalTypeBSAction::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeBSAction::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeBSAction::lower(const std::optional<BsAction>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeBSAction::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeBSAction::write(stream, val);

    return buf;
}

std::optional<BsAction> FfiConverterOptionalTypeBSAction::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeBSAction::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeBSAction::write(RustStream &stream, const std::optional<BsAction>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeBSAction::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeBSAction::allocation_size(const std::optional<BsAction> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeBSAction::allocation_size(val.value());
    }

    return ret;
}

std::optional<CallPut> FfiConverterOptionalTypeCallPut::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeCallPut::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeCallPut::lower(const std::optional<CallPut>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeCallPut::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeCallPut::write(stream, val);

    return buf;
}

std::optional<CallPut> FfiConverterOptionalTypeCallPut::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeCallPut::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeCallPut::write(RustStream &stream, const std::optional<CallPut>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeCallPut::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeCallPut::allocation_size(const std::optional<CallPut> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeCallPut::allocation_size(val.value());
    }

    return ret;
}

std::optional<ConditionStatus> FfiConverterOptionalTypeConditionStatus::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeConditionStatus::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeConditionStatus::lower(const std::optional<ConditionStatus>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeConditionStatus::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeConditionStatus::write(stream, val);

    return buf;
}

std::optional<ConditionStatus> FfiConverterOptionalTypeConditionStatus::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeConditionStatus::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeConditionStatus::write(RustStream &stream, const std::optional<ConditionStatus>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeConditionStatus::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeConditionStatus::allocation_size(const std::optional<ConditionStatus> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeConditionStatus::allocation_size(val.value());
    }

    return ret;
}

std::optional<FutOptConditionMarketType> FfiConverterOptionalTypeFutOptConditionMarketType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeFutOptConditionMarketType::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeFutOptConditionMarketType::lower(const std::optional<FutOptConditionMarketType>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeFutOptConditionMarketType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeFutOptConditionMarketType::write(stream, val);

    return buf;
}

std::optional<FutOptConditionMarketType> FfiConverterOptionalTypeFutOptConditionMarketType::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeFutOptConditionMarketType::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeFutOptConditionMarketType::write(RustStream &stream, const std::optional<FutOptConditionMarketType>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeFutOptConditionMarketType::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeFutOptConditionMarketType::allocation_size(const std::optional<FutOptConditionMarketType> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeFutOptConditionMarketType::allocation_size(val.value());
    }

    return ret;
}

std::optional<FutOptMarketType> FfiConverterOptionalTypeFutOptMarketType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeFutOptMarketType::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeFutOptMarketType::lower(const std::optional<FutOptMarketType>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeFutOptMarketType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeFutOptMarketType::write(stream, val);

    return buf;
}

std::optional<FutOptMarketType> FfiConverterOptionalTypeFutOptMarketType::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeFutOptMarketType::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeFutOptMarketType::write(RustStream &stream, const std::optional<FutOptMarketType>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeFutOptMarketType::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeFutOptMarketType::allocation_size(const std::optional<FutOptMarketType> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeFutOptMarketType::allocation_size(val.value());
    }

    return ret;
}

std::optional<FutOptOrderType> FfiConverterOptionalTypeFutOptOrderType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeFutOptOrderType::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeFutOptOrderType::lower(const std::optional<FutOptOrderType>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeFutOptOrderType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeFutOptOrderType::write(stream, val);

    return buf;
}

std::optional<FutOptOrderType> FfiConverterOptionalTypeFutOptOrderType::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeFutOptOrderType::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeFutOptOrderType::write(RustStream &stream, const std::optional<FutOptOrderType>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeFutOptOrderType::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeFutOptOrderType::allocation_size(const std::optional<FutOptOrderType> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeFutOptOrderType::allocation_size(val.value());
    }

    return ret;
}

std::optional<FutOptPriceType> FfiConverterOptionalTypeFutOptPriceType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeFutOptPriceType::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeFutOptPriceType::lower(const std::optional<FutOptPriceType>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeFutOptPriceType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeFutOptPriceType::write(stream, val);

    return buf;
}

std::optional<FutOptPriceType> FfiConverterOptionalTypeFutOptPriceType::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeFutOptPriceType::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeFutOptPriceType::write(RustStream &stream, const std::optional<FutOptPriceType>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeFutOptPriceType::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeFutOptPriceType::allocation_size(const std::optional<FutOptPriceType> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeFutOptPriceType::allocation_size(val.value());
    }

    return ret;
}

std::optional<HistoryStatus> FfiConverterOptionalTypeHistoryStatus::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeHistoryStatus::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeHistoryStatus::lower(const std::optional<HistoryStatus>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeHistoryStatus::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeHistoryStatus::write(stream, val);

    return buf;
}

std::optional<HistoryStatus> FfiConverterOptionalTypeHistoryStatus::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeHistoryStatus::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeHistoryStatus::write(RustStream &stream, const std::optional<HistoryStatus>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeHistoryStatus::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeHistoryStatus::allocation_size(const std::optional<HistoryStatus> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeHistoryStatus::allocation_size(val.value());
    }

    return ret;
}

std::optional<MarketType> FfiConverterOptionalTypeMarketType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeMarketType::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeMarketType::lower(const std::optional<MarketType>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeMarketType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeMarketType::write(stream, val);

    return buf;
}

std::optional<MarketType> FfiConverterOptionalTypeMarketType::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeMarketType::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeMarketType::write(RustStream &stream, const std::optional<MarketType>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeMarketType::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeMarketType::allocation_size(const std::optional<MarketType> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeMarketType::allocation_size(val.value());
    }

    return ret;
}

std::optional<OrderType> FfiConverterOptionalTypeOrderType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeOrderType::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeOrderType::lower(const std::optional<OrderType>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeOrderType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeOrderType::write(stream, val);

    return buf;
}

std::optional<OrderType> FfiConverterOptionalTypeOrderType::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeOrderType::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeOrderType::write(RustStream &stream, const std::optional<OrderType>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeOrderType::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeOrderType::allocation_size(const std::optional<OrderType> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeOrderType::allocation_size(val.value());
    }

    return ret;
}

std::optional<PriceType> FfiConverterOptionalTypePriceType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypePriceType::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypePriceType::lower(const std::optional<PriceType>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypePriceType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypePriceType::write(stream, val);

    return buf;
}

std::optional<PriceType> FfiConverterOptionalTypePriceType::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypePriceType::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypePriceType::write(RustStream &stream, const std::optional<PriceType>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypePriceType::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypePriceType::allocation_size(const std::optional<PriceType> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypePriceType::allocation_size(val.value());
    }

    return ret;
}

std::optional<TimeInForce> FfiConverterOptionalTypeTimeInForce::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeTimeInForce::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeTimeInForce::lower(const std::optional<TimeInForce>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeTimeInForce::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeTimeInForce::write(stream, val);

    return buf;
}

std::optional<TimeInForce> FfiConverterOptionalTypeTimeInForce::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeTimeInForce::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeTimeInForce::write(RustStream &stream, const std::optional<TimeInForce>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeTimeInForce::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeTimeInForce::allocation_size(const std::optional<TimeInForce> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeTimeInForce::allocation_size(val.value());
    }

    return ret;
}

std::optional<TriggerContent> FfiConverterOptionalTypeTriggerContent::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalTypeTriggerContent::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalTypeTriggerContent::lower(const std::optional<TriggerContent>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalTypeTriggerContent::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalTypeTriggerContent::write(stream, val);

    return buf;
}

std::optional<TriggerContent> FfiConverterOptionalTypeTriggerContent::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterTypeTriggerContent::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalTypeTriggerContent::write(RustStream &stream, const std::optional<TriggerContent>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterTypeTriggerContent::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalTypeTriggerContent::allocation_size(const std::optional<TriggerContent> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterTypeTriggerContent::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<Account>> FfiConverterOptionalSequenceTypeAccount::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeAccount::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeAccount::lower(const std::optional<std::vector<Account>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeAccount::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeAccount::write(stream, val);

    return buf;
}

std::optional<std::vector<Account>> FfiConverterOptionalSequenceTypeAccount::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeAccount::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeAccount::write(RustStream &stream, const std::optional<std::vector<Account>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeAccount::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeAccount::allocation_size(const std::optional<std::vector<Account>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeAccount::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<BatchResult>> FfiConverterOptionalSequenceTypeBatchResult::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeBatchResult::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeBatchResult::lower(const std::optional<std::vector<BatchResult>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeBatchResult::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeBatchResult::write(stream, val);

    return buf;
}

std::optional<std::vector<BatchResult>> FfiConverterOptionalSequenceTypeBatchResult::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeBatchResult::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeBatchResult::write(RustStream &stream, const std::optional<std::vector<BatchResult>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeBatchResult::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeBatchResult::allocation_size(const std::optional<std::vector<BatchResult>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeBatchResult::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<CloseRecord>> FfiConverterOptionalSequenceTypeCloseRecord::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeCloseRecord::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeCloseRecord::lower(const std::optional<std::vector<CloseRecord>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeCloseRecord::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeCloseRecord::write(stream, val);

    return buf;
}

std::optional<std::vector<CloseRecord>> FfiConverterOptionalSequenceTypeCloseRecord::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeCloseRecord::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeCloseRecord::write(RustStream &stream, const std::optional<std::vector<CloseRecord>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeCloseRecord::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeCloseRecord::allocation_size(const std::optional<std::vector<CloseRecord>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeCloseRecord::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<Condition>> FfiConverterOptionalSequenceTypeCondition::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeCondition::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeCondition::lower(const std::optional<std::vector<Condition>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeCondition::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeCondition::write(stream, val);

    return buf;
}

std::optional<std::vector<Condition>> FfiConverterOptionalSequenceTypeCondition::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeCondition::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeCondition::write(RustStream &stream, const std::optional<std::vector<Condition>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeCondition::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeCondition::allocation_size(const std::optional<std::vector<Condition>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeCondition::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<ConditionDetail>> FfiConverterOptionalSequenceTypeConditionDetail::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeConditionDetail::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeConditionDetail::lower(const std::optional<std::vector<ConditionDetail>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeConditionDetail::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeConditionDetail::write(stream, val);

    return buf;
}

std::optional<std::vector<ConditionDetail>> FfiConverterOptionalSequenceTypeConditionDetail::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeConditionDetail::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeConditionDetail::write(RustStream &stream, const std::optional<std::vector<ConditionDetail>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeConditionDetail::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeConditionDetail::allocation_size(const std::optional<std::vector<ConditionDetail>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeConditionDetail::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<Equity>> FfiConverterOptionalSequenceTypeEquity::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeEquity::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeEquity::lower(const std::optional<std::vector<Equity>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeEquity::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeEquity::write(stream, val);

    return buf;
}

std::optional<std::vector<Equity>> FfiConverterOptionalSequenceTypeEquity::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeEquity::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeEquity::write(RustStream &stream, const std::optional<std::vector<Equity>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeEquity::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeEquity::allocation_size(const std::optional<std::vector<Equity>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeEquity::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<FilledData>> FfiConverterOptionalSequenceTypeFilledData::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeFilledData::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeFilledData::lower(const std::optional<std::vector<FilledData>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeFilledData::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeFilledData::write(stream, val);

    return buf;
}

std::optional<std::vector<FilledData>> FfiConverterOptionalSequenceTypeFilledData::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeFilledData::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeFilledData::write(RustStream &stream, const std::optional<std::vector<FilledData>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeFilledData::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeFilledData::allocation_size(const std::optional<std::vector<FilledData>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeFilledData::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<FutOptFilledData>> FfiConverterOptionalSequenceTypeFutOptFilledData::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeFutOptFilledData::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeFutOptFilledData::lower(const std::optional<std::vector<FutOptFilledData>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeFutOptFilledData::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeFutOptFilledData::write(stream, val);

    return buf;
}

std::optional<std::vector<FutOptFilledData>> FfiConverterOptionalSequenceTypeFutOptFilledData::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeFutOptFilledData::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeFutOptFilledData::write(RustStream &stream, const std::optional<std::vector<FutOptFilledData>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeFutOptFilledData::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeFutOptFilledData::allocation_size(const std::optional<std::vector<FutOptFilledData>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeFutOptFilledData::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<FutOptOrderDetail>> FfiConverterOptionalSequenceTypeFutOptOrderDetail::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeFutOptOrderDetail::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeFutOptOrderDetail::lower(const std::optional<std::vector<FutOptOrderDetail>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeFutOptOrderDetail::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeFutOptOrderDetail::write(stream, val);

    return buf;
}

std::optional<std::vector<FutOptOrderDetail>> FfiConverterOptionalSequenceTypeFutOptOrderDetail::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeFutOptOrderDetail::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeFutOptOrderDetail::write(RustStream &stream, const std::optional<std::vector<FutOptOrderDetail>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeFutOptOrderDetail::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeFutOptOrderDetail::allocation_size(const std::optional<std::vector<FutOptOrderDetail>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeFutOptOrderDetail::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<FutOptOrderResult>> FfiConverterOptionalSequenceTypeFutOptOrderResult::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeFutOptOrderResult::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeFutOptOrderResult::lower(const std::optional<std::vector<FutOptOrderResult>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeFutOptOrderResult::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeFutOptOrderResult::write(stream, val);

    return buf;
}

std::optional<std::vector<FutOptOrderResult>> FfiConverterOptionalSequenceTypeFutOptOrderResult::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeFutOptOrderResult::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeFutOptOrderResult::write(RustStream &stream, const std::optional<std::vector<FutOptOrderResult>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeFutOptOrderResult::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeFutOptOrderResult::allocation_size(const std::optional<std::vector<FutOptOrderResult>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeFutOptOrderResult::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<HybridPosition>> FfiConverterOptionalSequenceTypeHybridPosition::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeHybridPosition::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeHybridPosition::lower(const std::optional<std::vector<HybridPosition>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeHybridPosition::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeHybridPosition::write(stream, val);

    return buf;
}

std::optional<std::vector<HybridPosition>> FfiConverterOptionalSequenceTypeHybridPosition::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeHybridPosition::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeHybridPosition::write(RustStream &stream, const std::optional<std::vector<HybridPosition>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeHybridPosition::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeHybridPosition::allocation_size(const std::optional<std::vector<HybridPosition>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeHybridPosition::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<Inventory>> FfiConverterOptionalSequenceTypeInventory::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeInventory::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeInventory::lower(const std::optional<std::vector<Inventory>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeInventory::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeInventory::write(stream, val);

    return buf;
}

std::optional<std::vector<Inventory>> FfiConverterOptionalSequenceTypeInventory::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeInventory::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeInventory::write(RustStream &stream, const std::optional<std::vector<Inventory>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeInventory::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeInventory::allocation_size(const std::optional<std::vector<Inventory>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeInventory::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<OrderDetail>> FfiConverterOptionalSequenceTypeOrderDetail::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeOrderDetail::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeOrderDetail::lower(const std::optional<std::vector<OrderDetail>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeOrderDetail::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeOrderDetail::write(stream, val);

    return buf;
}

std::optional<std::vector<OrderDetail>> FfiConverterOptionalSequenceTypeOrderDetail::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeOrderDetail::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeOrderDetail::write(RustStream &stream, const std::optional<std::vector<OrderDetail>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeOrderDetail::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeOrderDetail::allocation_size(const std::optional<std::vector<OrderDetail>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeOrderDetail::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<OrderResult>> FfiConverterOptionalSequenceTypeOrderResult::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeOrderResult::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeOrderResult::lower(const std::optional<std::vector<OrderResult>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeOrderResult::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeOrderResult::write(stream, val);

    return buf;
}

std::optional<std::vector<OrderResult>> FfiConverterOptionalSequenceTypeOrderResult::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeOrderResult::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeOrderResult::write(RustStream &stream, const std::optional<std::vector<OrderResult>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeOrderResult::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeOrderResult::allocation_size(const std::optional<std::vector<OrderResult>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeOrderResult::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<Position>> FfiConverterOptionalSequenceTypePosition::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypePosition::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypePosition::lower(const std::optional<std::vector<Position>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypePosition::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypePosition::write(stream, val);

    return buf;
}

std::optional<std::vector<Position>> FfiConverterOptionalSequenceTypePosition::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypePosition::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypePosition::write(RustStream &stream, const std::optional<std::vector<Position>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypePosition::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypePosition::allocation_size(const std::optional<std::vector<Position>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypePosition::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<Realized>> FfiConverterOptionalSequenceTypeRealized::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeRealized::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeRealized::lower(const std::optional<std::vector<Realized>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeRealized::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeRealized::write(stream, val);

    return buf;
}

std::optional<std::vector<Realized>> FfiConverterOptionalSequenceTypeRealized::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeRealized::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeRealized::write(RustStream &stream, const std::optional<std::vector<Realized>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeRealized::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeRealized::allocation_size(const std::optional<std::vector<Realized>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeRealized::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<RealizedSummary>> FfiConverterOptionalSequenceTypeRealizedSummary::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeRealizedSummary::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeRealizedSummary::lower(const std::optional<std::vector<RealizedSummary>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeRealizedSummary::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeRealizedSummary::write(stream, val);

    return buf;
}

std::optional<std::vector<RealizedSummary>> FfiConverterOptionalSequenceTypeRealizedSummary::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeRealizedSummary::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeRealizedSummary::write(RustStream &stream, const std::optional<std::vector<RealizedSummary>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeRealizedSummary::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeRealizedSummary::allocation_size(const std::optional<std::vector<RealizedSummary>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeRealizedSummary::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<Recover>> FfiConverterOptionalSequenceTypeRecover::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeRecover::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeRecover::lower(const std::optional<std::vector<Recover>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeRecover::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeRecover::write(stream, val);

    return buf;
}

std::optional<std::vector<Recover>> FfiConverterOptionalSequenceTypeRecover::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeRecover::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeRecover::write(RustStream &stream, const std::optional<std::vector<Recover>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeRecover::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeRecover::allocation_size(const std::optional<std::vector<Recover>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeRecover::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<Settlement>> FfiConverterOptionalSequenceTypeSettlement::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeSettlement::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeSettlement::lower(const std::optional<std::vector<Settlement>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeSettlement::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeSettlement::write(stream, val);

    return buf;
}

std::optional<std::vector<Settlement>> FfiConverterOptionalSequenceTypeSettlement::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeSettlement::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeSettlement::write(RustStream &stream, const std::optional<std::vector<Settlement>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeSettlement::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeSettlement::allocation_size(const std::optional<std::vector<Settlement>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeSettlement::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<SpreadPosition>> FfiConverterOptionalSequenceTypeSpreadPosition::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeSpreadPosition::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeSpreadPosition::lower(const std::optional<std::vector<SpreadPosition>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeSpreadPosition::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeSpreadPosition::write(stream, val);

    return buf;
}

std::optional<std::vector<SpreadPosition>> FfiConverterOptionalSequenceTypeSpreadPosition::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeSpreadPosition::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeSpreadPosition::write(RustStream &stream, const std::optional<std::vector<SpreadPosition>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeSpreadPosition::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeSpreadPosition::allocation_size(const std::optional<std::vector<SpreadPosition>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeSpreadPosition::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<SymbolQuote>> FfiConverterOptionalSequenceTypeSymbolQuote::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeSymbolQuote::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeSymbolQuote::lower(const std::optional<std::vector<SymbolQuote>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeSymbolQuote::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeSymbolQuote::write(stream, val);

    return buf;
}

std::optional<std::vector<SymbolQuote>> FfiConverterOptionalSequenceTypeSymbolQuote::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeSymbolQuote::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeSymbolQuote::write(RustStream &stream, const std::optional<std::vector<SymbolQuote>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeSymbolQuote::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeSymbolQuote::allocation_size(const std::optional<std::vector<SymbolQuote>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeSymbolQuote::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<Unrealized>> FfiConverterOptionalSequenceTypeUnrealized::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeUnrealized::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeUnrealized::lower(const std::optional<std::vector<Unrealized>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeUnrealized::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeUnrealized::write(stream, val);

    return buf;
}

std::optional<std::vector<Unrealized>> FfiConverterOptionalSequenceTypeUnrealized::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeUnrealized::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeUnrealized::write(RustStream &stream, const std::optional<std::vector<Unrealized>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeUnrealized::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeUnrealized::allocation_size(const std::optional<std::vector<Unrealized>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeUnrealized::allocation_size(val.value());
    }

    return ret;
}

std::optional<std::vector<StockType>> FfiConverterOptionalSequenceTypeStockType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalSequenceTypeStockType::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalSequenceTypeStockType::lower(const std::optional<std::vector<StockType>>& val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalSequenceTypeStockType::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalSequenceTypeStockType::write(stream, val);

    return buf;
}

std::optional<std::vector<StockType>> FfiConverterOptionalSequenceTypeStockType::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterSequenceTypeStockType::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalSequenceTypeStockType::write(RustStream &stream, const std::optional<std::vector<StockType>>& value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterSequenceTypeStockType::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalSequenceTypeStockType::allocation_size(const std::optional<std::vector<StockType>> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterSequenceTypeStockType::allocation_size(val.value());
    }

    return ret;
}


std::vector<Account> FfiConverterSequenceTypeAccount::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeAccount::lower(const std::vector<Account> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<Account> FfiConverterSequenceTypeAccount::read(RustStream &stream) {
    std::vector<Account> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeAccount::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeAccount::write(RustStream &stream, const std::vector<Account> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeAccount::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeAccount::allocation_size(const std::vector<Account> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeAccount::allocation_size(elem);
    }

    return size;
}


std::vector<BatchResult> FfiConverterSequenceTypeBatchResult::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeBatchResult::lower(const std::vector<BatchResult> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<BatchResult> FfiConverterSequenceTypeBatchResult::read(RustStream &stream) {
    std::vector<BatchResult> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeBatchResult::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeBatchResult::write(RustStream &stream, const std::vector<BatchResult> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeBatchResult::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeBatchResult::allocation_size(const std::vector<BatchResult> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeBatchResult::allocation_size(elem);
    }

    return size;
}


std::vector<CloseRecord> FfiConverterSequenceTypeCloseRecord::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeCloseRecord::lower(const std::vector<CloseRecord> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<CloseRecord> FfiConverterSequenceTypeCloseRecord::read(RustStream &stream) {
    std::vector<CloseRecord> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeCloseRecord::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeCloseRecord::write(RustStream &stream, const std::vector<CloseRecord> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeCloseRecord::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeCloseRecord::allocation_size(const std::vector<CloseRecord> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeCloseRecord::allocation_size(elem);
    }

    return size;
}


std::vector<Condition> FfiConverterSequenceTypeCondition::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeCondition::lower(const std::vector<Condition> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<Condition> FfiConverterSequenceTypeCondition::read(RustStream &stream) {
    std::vector<Condition> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeCondition::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeCondition::write(RustStream &stream, const std::vector<Condition> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeCondition::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeCondition::allocation_size(const std::vector<Condition> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeCondition::allocation_size(elem);
    }

    return size;
}


std::vector<ConditionDetail> FfiConverterSequenceTypeConditionDetail::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeConditionDetail::lower(const std::vector<ConditionDetail> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<ConditionDetail> FfiConverterSequenceTypeConditionDetail::read(RustStream &stream) {
    std::vector<ConditionDetail> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeConditionDetail::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeConditionDetail::write(RustStream &stream, const std::vector<ConditionDetail> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeConditionDetail::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeConditionDetail::allocation_size(const std::vector<ConditionDetail> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeConditionDetail::allocation_size(elem);
    }

    return size;
}


std::vector<Equity> FfiConverterSequenceTypeEquity::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeEquity::lower(const std::vector<Equity> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<Equity> FfiConverterSequenceTypeEquity::read(RustStream &stream) {
    std::vector<Equity> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeEquity::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeEquity::write(RustStream &stream, const std::vector<Equity> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeEquity::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeEquity::allocation_size(const std::vector<Equity> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeEquity::allocation_size(elem);
    }

    return size;
}


std::vector<FilledData> FfiConverterSequenceTypeFilledData::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeFilledData::lower(const std::vector<FilledData> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<FilledData> FfiConverterSequenceTypeFilledData::read(RustStream &stream) {
    std::vector<FilledData> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeFilledData::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeFilledData::write(RustStream &stream, const std::vector<FilledData> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeFilledData::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeFilledData::allocation_size(const std::vector<FilledData> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeFilledData::allocation_size(elem);
    }

    return size;
}


std::vector<FutOptFilledData> FfiConverterSequenceTypeFutOptFilledData::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeFutOptFilledData::lower(const std::vector<FutOptFilledData> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<FutOptFilledData> FfiConverterSequenceTypeFutOptFilledData::read(RustStream &stream) {
    std::vector<FutOptFilledData> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeFutOptFilledData::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeFutOptFilledData::write(RustStream &stream, const std::vector<FutOptFilledData> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeFutOptFilledData::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeFutOptFilledData::allocation_size(const std::vector<FutOptFilledData> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeFutOptFilledData::allocation_size(elem);
    }

    return size;
}


std::vector<FutOptModifyLot> FfiConverterSequenceTypeFutOptModifyLot::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeFutOptModifyLot::lower(const std::vector<FutOptModifyLot> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<FutOptModifyLot> FfiConverterSequenceTypeFutOptModifyLot::read(RustStream &stream) {
    std::vector<FutOptModifyLot> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeFutOptModifyLot::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeFutOptModifyLot::write(RustStream &stream, const std::vector<FutOptModifyLot> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeFutOptModifyLot::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeFutOptModifyLot::allocation_size(const std::vector<FutOptModifyLot> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeFutOptModifyLot::allocation_size(elem);
    }

    return size;
}


std::vector<FutOptModifyPrice> FfiConverterSequenceTypeFutOptModifyPrice::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeFutOptModifyPrice::lower(const std::vector<FutOptModifyPrice> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<FutOptModifyPrice> FfiConverterSequenceTypeFutOptModifyPrice::read(RustStream &stream) {
    std::vector<FutOptModifyPrice> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeFutOptModifyPrice::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeFutOptModifyPrice::write(RustStream &stream, const std::vector<FutOptModifyPrice> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeFutOptModifyPrice::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeFutOptModifyPrice::allocation_size(const std::vector<FutOptModifyPrice> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeFutOptModifyPrice::allocation_size(elem);
    }

    return size;
}


std::vector<FutOptOrder> FfiConverterSequenceTypeFutOptOrder::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeFutOptOrder::lower(const std::vector<FutOptOrder> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<FutOptOrder> FfiConverterSequenceTypeFutOptOrder::read(RustStream &stream) {
    std::vector<FutOptOrder> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeFutOptOrder::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeFutOptOrder::write(RustStream &stream, const std::vector<FutOptOrder> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeFutOptOrder::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeFutOptOrder::allocation_size(const std::vector<FutOptOrder> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeFutOptOrder::allocation_size(elem);
    }

    return size;
}


std::vector<FutOptOrderDetail> FfiConverterSequenceTypeFutOptOrderDetail::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeFutOptOrderDetail::lower(const std::vector<FutOptOrderDetail> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<FutOptOrderDetail> FfiConverterSequenceTypeFutOptOrderDetail::read(RustStream &stream) {
    std::vector<FutOptOrderDetail> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeFutOptOrderDetail::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeFutOptOrderDetail::write(RustStream &stream, const std::vector<FutOptOrderDetail> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeFutOptOrderDetail::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeFutOptOrderDetail::allocation_size(const std::vector<FutOptOrderDetail> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeFutOptOrderDetail::allocation_size(elem);
    }

    return size;
}


std::vector<FutOptOrderResult> FfiConverterSequenceTypeFutOptOrderResult::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeFutOptOrderResult::lower(const std::vector<FutOptOrderResult> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<FutOptOrderResult> FfiConverterSequenceTypeFutOptOrderResult::read(RustStream &stream) {
    std::vector<FutOptOrderResult> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeFutOptOrderResult::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeFutOptOrderResult::write(RustStream &stream, const std::vector<FutOptOrderResult> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeFutOptOrderResult::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeFutOptOrderResult::allocation_size(const std::vector<FutOptOrderResult> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeFutOptOrderResult::allocation_size(elem);
    }

    return size;
}


std::vector<HybridPosition> FfiConverterSequenceTypeHybridPosition::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeHybridPosition::lower(const std::vector<HybridPosition> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<HybridPosition> FfiConverterSequenceTypeHybridPosition::read(RustStream &stream) {
    std::vector<HybridPosition> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeHybridPosition::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeHybridPosition::write(RustStream &stream, const std::vector<HybridPosition> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeHybridPosition::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeHybridPosition::allocation_size(const std::vector<HybridPosition> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeHybridPosition::allocation_size(elem);
    }

    return size;
}


std::vector<Inventory> FfiConverterSequenceTypeInventory::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeInventory::lower(const std::vector<Inventory> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<Inventory> FfiConverterSequenceTypeInventory::read(RustStream &stream) {
    std::vector<Inventory> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeInventory::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeInventory::write(RustStream &stream, const std::vector<Inventory> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeInventory::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeInventory::allocation_size(const std::vector<Inventory> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeInventory::allocation_size(elem);
    }

    return size;
}


std::vector<MaintenanceDetail> FfiConverterSequenceTypeMaintenanceDetail::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeMaintenanceDetail::lower(const std::vector<MaintenanceDetail> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<MaintenanceDetail> FfiConverterSequenceTypeMaintenanceDetail::read(RustStream &stream) {
    std::vector<MaintenanceDetail> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeMaintenanceDetail::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeMaintenanceDetail::write(RustStream &stream, const std::vector<MaintenanceDetail> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeMaintenanceDetail::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeMaintenanceDetail::allocation_size(const std::vector<MaintenanceDetail> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeMaintenanceDetail::allocation_size(elem);
    }

    return size;
}


std::vector<ModifyPrice> FfiConverterSequenceTypeModifyPrice::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeModifyPrice::lower(const std::vector<ModifyPrice> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<ModifyPrice> FfiConverterSequenceTypeModifyPrice::read(RustStream &stream) {
    std::vector<ModifyPrice> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeModifyPrice::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeModifyPrice::write(RustStream &stream, const std::vector<ModifyPrice> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeModifyPrice::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeModifyPrice::allocation_size(const std::vector<ModifyPrice> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeModifyPrice::allocation_size(elem);
    }

    return size;
}


std::vector<ModifyQuantity> FfiConverterSequenceTypeModifyQuantity::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeModifyQuantity::lower(const std::vector<ModifyQuantity> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<ModifyQuantity> FfiConverterSequenceTypeModifyQuantity::read(RustStream &stream) {
    std::vector<ModifyQuantity> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeModifyQuantity::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeModifyQuantity::write(RustStream &stream, const std::vector<ModifyQuantity> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeModifyQuantity::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeModifyQuantity::allocation_size(const std::vector<ModifyQuantity> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeModifyQuantity::allocation_size(elem);
    }

    return size;
}


std::vector<Order> FfiConverterSequenceTypeOrder::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeOrder::lower(const std::vector<Order> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<Order> FfiConverterSequenceTypeOrder::read(RustStream &stream) {
    std::vector<Order> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeOrder::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeOrder::write(RustStream &stream, const std::vector<Order> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeOrder::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeOrder::allocation_size(const std::vector<Order> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeOrder::allocation_size(elem);
    }

    return size;
}


std::vector<OrderDetail> FfiConverterSequenceTypeOrderDetail::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeOrderDetail::lower(const std::vector<OrderDetail> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<OrderDetail> FfiConverterSequenceTypeOrderDetail::read(RustStream &stream) {
    std::vector<OrderDetail> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeOrderDetail::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeOrderDetail::write(RustStream &stream, const std::vector<OrderDetail> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeOrderDetail::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeOrderDetail::allocation_size(const std::vector<OrderDetail> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeOrderDetail::allocation_size(elem);
    }

    return size;
}


std::vector<OrderResult> FfiConverterSequenceTypeOrderResult::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeOrderResult::lower(const std::vector<OrderResult> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<OrderResult> FfiConverterSequenceTypeOrderResult::read(RustStream &stream) {
    std::vector<OrderResult> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeOrderResult::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeOrderResult::write(RustStream &stream, const std::vector<OrderResult> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeOrderResult::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeOrderResult::allocation_size(const std::vector<OrderResult> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeOrderResult::allocation_size(elem);
    }

    return size;
}


std::vector<ParentChildRecord> FfiConverterSequenceTypeParentChildRecord::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeParentChildRecord::lower(const std::vector<ParentChildRecord> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<ParentChildRecord> FfiConverterSequenceTypeParentChildRecord::read(RustStream &stream) {
    std::vector<ParentChildRecord> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeParentChildRecord::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeParentChildRecord::write(RustStream &stream, const std::vector<ParentChildRecord> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeParentChildRecord::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeParentChildRecord::allocation_size(const std::vector<ParentChildRecord> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeParentChildRecord::allocation_size(elem);
    }

    return size;
}


std::vector<Position> FfiConverterSequenceTypePosition::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypePosition::lower(const std::vector<Position> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<Position> FfiConverterSequenceTypePosition::read(RustStream &stream) {
    std::vector<Position> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypePosition::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypePosition::write(RustStream &stream, const std::vector<Position> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypePosition::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypePosition::allocation_size(const std::vector<Position> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypePosition::allocation_size(elem);
    }

    return size;
}


std::vector<Realized> FfiConverterSequenceTypeRealized::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeRealized::lower(const std::vector<Realized> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<Realized> FfiConverterSequenceTypeRealized::read(RustStream &stream) {
    std::vector<Realized> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeRealized::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeRealized::write(RustStream &stream, const std::vector<Realized> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeRealized::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeRealized::allocation_size(const std::vector<Realized> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeRealized::allocation_size(elem);
    }

    return size;
}


std::vector<RealizedSummary> FfiConverterSequenceTypeRealizedSummary::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeRealizedSummary::lower(const std::vector<RealizedSummary> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<RealizedSummary> FfiConverterSequenceTypeRealizedSummary::read(RustStream &stream) {
    std::vector<RealizedSummary> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeRealizedSummary::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeRealizedSummary::write(RustStream &stream, const std::vector<RealizedSummary> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeRealizedSummary::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeRealizedSummary::allocation_size(const std::vector<RealizedSummary> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeRealizedSummary::allocation_size(elem);
    }

    return size;
}


std::vector<Recover> FfiConverterSequenceTypeRecover::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeRecover::lower(const std::vector<Recover> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<Recover> FfiConverterSequenceTypeRecover::read(RustStream &stream) {
    std::vector<Recover> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeRecover::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeRecover::write(RustStream &stream, const std::vector<Recover> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeRecover::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeRecover::allocation_size(const std::vector<Recover> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeRecover::allocation_size(elem);
    }

    return size;
}


std::vector<Settlement> FfiConverterSequenceTypeSettlement::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeSettlement::lower(const std::vector<Settlement> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<Settlement> FfiConverterSequenceTypeSettlement::read(RustStream &stream) {
    std::vector<Settlement> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeSettlement::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeSettlement::write(RustStream &stream, const std::vector<Settlement> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeSettlement::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeSettlement::allocation_size(const std::vector<Settlement> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeSettlement::allocation_size(elem);
    }

    return size;
}


std::vector<SpreadPosition> FfiConverterSequenceTypeSpreadPosition::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeSpreadPosition::lower(const std::vector<SpreadPosition> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<SpreadPosition> FfiConverterSequenceTypeSpreadPosition::read(RustStream &stream) {
    std::vector<SpreadPosition> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeSpreadPosition::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeSpreadPosition::write(RustStream &stream, const std::vector<SpreadPosition> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeSpreadPosition::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeSpreadPosition::allocation_size(const std::vector<SpreadPosition> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeSpreadPosition::allocation_size(elem);
    }

    return size;
}


std::vector<SymbolQuote> FfiConverterSequenceTypeSymbolQuote::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeSymbolQuote::lower(const std::vector<SymbolQuote> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<SymbolQuote> FfiConverterSequenceTypeSymbolQuote::read(RustStream &stream) {
    std::vector<SymbolQuote> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeSymbolQuote::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeSymbolQuote::write(RustStream &stream, const std::vector<SymbolQuote> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeSymbolQuote::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeSymbolQuote::allocation_size(const std::vector<SymbolQuote> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeSymbolQuote::allocation_size(elem);
    }

    return size;
}


std::vector<Unrealized> FfiConverterSequenceTypeUnrealized::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeUnrealized::lower(const std::vector<Unrealized> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<Unrealized> FfiConverterSequenceTypeUnrealized::read(RustStream &stream) {
    std::vector<Unrealized> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeUnrealized::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeUnrealized::write(RustStream &stream, const std::vector<Unrealized> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeUnrealized::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeUnrealized::allocation_size(const std::vector<Unrealized> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeUnrealized::allocation_size(elem);
    }

    return size;
}


std::vector<StockType> FfiConverterSequenceTypeStockType::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterSequenceTypeStockType::lower(const std::vector<StockType> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<StockType> FfiConverterSequenceTypeStockType::read(RustStream &stream) {
    std::vector<StockType> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        ret.push_back(FfiConverterTypeStockType::read(stream));
    }

    return ret;
}

void FfiConverterSequenceTypeStockType::write(RustStream &stream, const std::vector<StockType> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        FfiConverterTypeStockType::write(stream, elem);
    }
}

int32_t FfiConverterSequenceTypeStockType::allocation_size(const std::vector<StockType> &val) {
    int32_t size = sizeof(int32_t);

    for (auto &elem : val) {
        size += FfiConverterTypeStockType::allocation_size(elem);
    }

    return size;
}

}} // namespace fubon